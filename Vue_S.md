# Vue

### 1.指令

**1.1 作用：**提供对DOM元素的**直接操作和控制**

**1.2 内置指令：**	

1. **v-bind：**单向绑定数据

2. **v-model：**在**表单元素**上实现**双向数据**绑定

   > 语法糖,实际上是对组件的 `value` 属性和 `input` 事件进行了封装
   >
   > ```html
   > <input type="text" v-model="name">
   > ```
   >
   > ```html
   > <input type="text" :value="name" @input="name = $event.target.value">
   > ```
   >

3. **v-for：**用于渲染列表数据，根据**数组或对象**的内容进行循环渲染。

4. **v-if / v-else-if / v-else：**根据表达式的值进行条件渲染

5. **v-show：**条件渲染元素

   > **与 `v-if` 不同的是**：`v-show` 只是用 CSS 的 `display` 属性来**控制元素的显示与隐藏**，而不会**重新**渲染元素

6. **v-on：**绑定事件监听，简写为 `@`

7. **v-text：**向其所在的节点中渲染**文本内容**（双向）

   > **与插值语法的区别：**
   >
   > 1. `v-text` 会**替换掉节点中的内容**，`{{ }}`不会，更灵活。
   >
   > 2.  `v-text` 可以在**元素初始化**时避免出现闪烁。                 
   >
   > **原因：**
   >
   > ​	**页面渲染**的时，Vue先进行**模板编译**---->将模板转换为**虚拟的DOM**---->并建立起**与数据之间的关联**
   >
   > **插值表达式**
   >
   > ​	在初始化的过程中，当**Vue还未完成数据响应式的更新**的时候，插值表达式会显示为**占位符**，直到**数据更新**后才会被**替换为真正的值**
   >
   > **v-text**
   >
   > ​	当 Vue 进行初始化时，`v-text` 指令会**立即将绑定的数据**显示在元素上，避免了出现插值表达式的占位符

8. **v-html :** 向其所在的节点中渲染**包含html结构的内容**（双向绑定）。

   > **与其他的区别：**
   >
   > （1）`v-html`会替换节点的所有内容，`v-text` 指令直接替换元素的文本内容，`{{XXX}}`不会；
   >
   > （2）`v-html`可以识别html结构
   >
   > **存在安全问题：**
   >
   > ​	易受`XSS`攻击，要确保渲染的内容是可信的
   >
   > ​	XSS（Cross-Site Scripting）攻击是一种常见的网络安全漏洞。
   >
   > ​	XSS 攻击的原理：**攻击者**通过在**受信任网站**上注入**恶意脚本**，这些脚本可以由用户浏览器执行。
   >
   > 恶意脚本可以**窃取用户的敏感信息**，如登录凭据、Cookie 数据，甚至可以**修改网页内容**或**重定向用户到恶意网站**。

9. **ref：**为某个元素注册一个唯一标识, vue对象通过`$refs`属性访问这个元素对象

> ref用来获取DOM元素。this.$ref.test获取到这个dom ，然后做一些操作
>
> 获取子组件的一些方法  this.$ref.test拿到vue组件对象，里面有$el属性，this.$ref.test.msg拿到值，拿到方法

1. **v-cloak：**配合`css`使用，用于解决在初始渲染过程中出现**闪烁**的问题

   > ```html
   > <div v-clock>{{ data }}</div>
   > 
   > [v-clock] {
   > 	display: none;
   > }
   > ```
   >
   > 比如网速慢等，页面出现闪烁的问题，展示出`{{XXX}}`。
   >
   > `v-cloak` 的作用是在 Vue 实例**渲染完成之前**，**将元素隐藏起来**，直到 Vue 实例**完成编译和渲染**，然后再移除隐藏样式，确保元素显示出预期的效果。

2. **v-once：**所在的节点**初次渲染**后，就视为**静态内容**了，以后的数据改变不会引起该节点所在的结构更新，可用于数据优化

3. **v-pre： 跳过所在节点的编译过程**,用它跳过没有使用**指令语法,插值语法**的节点,加快编译

##### **1.3 自定义指令：**

​	**1.全局注册：**`Vue.directive(指令名,配置对象/回调函数)`

​	**2.局部注册:** 通过在组件`options`选项中设置`directive`属性

```js
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
    }
  }
}
```

> **自定义指令也像组件那样存在钩子函数：**
>
> - `bind`：指令与元素**成功绑定时**（只调用一次）
> - `inserted`：指令所在的元素**被插入到页面时调用**
> - `update`：指令**所在的模板结构被重新解析时调用**
>
> **所有的钩子函数的参数都有以下：**
>
> - `el`：指令所绑定 `DOM`元素
> - `binding`:要绑定的对象，包含以下`property`:
>   - `name`：指令名，不包括 `v-` 前缀
>   - `value`：指令的绑定值
>   - `oldValue`：指令绑定的前一个值
>   - `expression`：字符串形式的指令表达式
>   - `arg`：传给指令的参数
>   - `modifiers`：一个包含修饰符的对象
>

##### **1.4 应用场景:**

- 表单防止重复提交
- 图片懒加载
- 一键 Copy的功能

```js
import { throttle } from 'lodash';

const LazyLoad = {
    // install方法 将其注册为Vue插件
    install(Vue,options){
    	  // 默认的 loading 图片路径
        let defaultSrc = options.default;
        //自定义地指令
        Vue.directive('lazy',{
            // 当指令绑定到元素上时触发 binding绑定的值
            bind(el,binding){
                //初始化元素
                LazyLoad.init(el,binding.value,defaultSrc);
            },
            // 当绑定的元素插入到父节点时触发
            inserted(el){
                // 兼容处理 判断浏览器是否支持 IntersectionObserver
                if('IntersectionObserver' in window){
                    // 使用 IntersectionObserver 监听元素
                    LazyLoad.observe(el);
                }else{
                    // 使用滚动监听来实现懒加载
                    LazyLoad.listenerScroll(el);
                }
                
            },
        })
    },
    // 初始化
    init(el,val,def){
        // data-src 储存真实src
        el.setAttribute('data-src',val);
        // 设置src为loading图
        el.setAttribute('src',def);
    },
    // 利用IntersectionObserver监听el
    observe(el){
//IntersectionObserver 是一个用于异步监听目标元素与其祖先元素或视窗(viewport)交叉状态的 API。它提供了一种有效的方式来检测元素是否进入或离开视窗可见区域，或者与包含它的容器发生交叉。
        // 创建一个 IntersectionObserver 实例
        let io = new IntersectionObserver(entries => {
            let realSrc = el.dataset.src;
            if(entries[0].isIntersecting){
                if(realSrc){
                    // 当元素进入可视区域时，将真实的图片地址赋值给 `src` 属性
                    el.src = realSrc;
                    el.removeAttribute('data-src');
                }
            }
        });
        io.observe(el);
    },
    // 使用滚动监听来实现懒加载
    listenerScroll(el){
        // 定义节流函数
        let handler = throttle(LazyLoad.load,300);
        // 初始化加载元素
        LazyLoad.load(el);
        // 监听滚动事件
        window.addEventListener('scroll',() => {
            handler(el);
        });
    },
    // 加载真实图片
    load(el){
        // 获取窗口高度
        let windowHeight = document.documentElement.clientHeight
        // 获取元素相对于视口的位置信息
        let elTop = el.getBoundingClientRect().top;
        let elBtm = el.getBoundingClientRect().bottom;
        // 获取真实的图片地址
        let realSrc = el.dataset.src;
        if(elTop - windowHeight<0&&elBtm > 0){
            if(realSrc){
                // 当元素在可视区域内时，将真实的图片地址赋值给 `src` 属性
                el.src = realSrc;
                el.removeAttribute('data-src');
            }
        }
    },
}

export default LazyLoad;
```

> 如何写一个自定义指令，为什么要用自定义指令而不是其他的方案？
>
> 1. 在**多个组件中共享和复用**
> 2. **直接操作 DOM**
> 3. 可以将一些和视图相关的**逻辑抽离到指令**中，让组件更专注于**数据和业务逻辑**，提高代码的可读性和可维护性。

-----

### 2. v-if 与 v-show 

**相同点：**

​		 都是控制元素显示与隐藏的指令

**不同点：**

​		**v-show：**通过`display`属性控制元素的显示与隐藏，控制的元素无论是true，还是false，都被**渲染出来了**

​		**v-if：**控制的元素是true，进行渲染，是**false不渲染，在dom树结构中不存在**

**适用的场景：**

​		**v-show：**适合使用在切换频繁显示/隐藏的元素上

​		**v-if：**适合使用在切换不频繁显示/隐藏的元素上，且**元素的内容很多，渲染一次性能消耗很大的元素上**

-----

### 3.v-for与v-if

**作用：**

​	**v-if：**根据表达式的值进行条件渲染

​	**v-for：**遍历数组/对象/字符串来渲染列表数据 建议设置`key`值，并且保证每个`key`值是独一无二的，这便于**`diff`算法进行优化**

**优先级：**

​	**`v-for`优先级比`v-if`高**

1. 永远不要把 `v-if` 和 `v-for` 同时用在**同一个元素上**，**带来性能方面的浪费**（每次渲染都会先循环再进行条件判断）
2. 如果避免出现这种情况，则在外层嵌套`template`（页面渲染不生成`dom`节点），在这一层进行`v-if`判断，然后在内部进行`v-for`循环
3. 如果条件出现在循环内部，可通过计算属性`computed`提前过滤掉那些不需要显示的项

-----

### 4.watch computed

**作用：**

​	**computed：** 是计算属性，**依赖其它属性值**， computed 的值有**缓存**，只有它依赖的属性值发生改变，才会重新计算 computed 的值；

​	**watch：** 更多的是**观察的作用**，支持**异步**，监听**指定的数据的变化**，并在变化发生时**执行特定的操作**

**应用场景：**

​	**computed**需要进行**数值计算**，并且**依赖于其它数据时**，应该使用 computed，因为可以**利用 computed 的缓存特性，避免每次获取值时，都要重新计算；** 

​	**watch**需要**在数据变化时执行异步或开销较大的操作**时，应该使用 watch，使用 watch 选项允许我们**执行异步操作** (发送网络请求、调用API)，**限制我们执行该操作的频率**(immediate)，并在我们得到最终结果前，**设置中间状态**(在异步操作完成之前提供一个反馈或占位状态)。这些都是计算属性无法做到的。适用于需要对**数据变化进行响应式处理的场景**

> **computed**值有缓存、触发条件是依赖值发生更改、 
>
> **watch**无缓存支持异步、监听数据变化 

-----

### 5.为什么组件中的data属性是一个函数而不是一个对象？

为了防止多个组件实例对象之间共用一个`data`，产生数据污染

多个组件实例之间共享的是**同一个对象引用**。这会导致**一个实例对数据的修改会影响其他实例**

-----

### 6.Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗?

**(1) 不会立刻渲染**

​		Vue采用**异步的**方式来更新视图,提高性能和效率

​		当你修改 `data` 中的某个属性时，Vue 会将该修改标记为**"脏"**，并在**下一个事件循环**中进行视图的更新。

​		这意味着，**如果在同一个事件循环中多次修改同一个属性(循环操作)，Vue 只会进行一次视图更新**，而不会对每次修改都重新渲染视图。

**(2) 若需要在数据变化后立即执行某些操作?**

​		`watch` 属性: 来监听数据的变化并**执行相应的操作**

​		`computed`属性: 在计算属性中定义一个 `getter` 函数，并在函数中执行你需要的操作

​		`$nextTick` 方法: 允许你在**下一次 DOM 更新周期之后**执行回调函数，确保在视图更新后再执行你的操作

-----

### 7.this

**组件中的this：**

​	默认指向**组件实例**，可以在使用`this`访问**组件的属性，方法，生命周期钩子**

**回调函数中的this：**

​		指向**可能会发生变化**

​		在一个**异步回调函数**中，`this` 的指向可能不再是组件实例，例如定时器中的`this`，可能指向的是全局对象，浏览器中是 `window`

​		为了确保在回调函数中仍然能够访问到组件实例，可以使用**箭头函数**或在**回调函数**中使用 `bind` 方法来绑定 `this`。
**箭头函数的this指向：**

​	是在定义的时候决定的，而不是运行的时候决定的，箭头函数没有自己的this，会继承外部作用域的this

-----

### 8.事件对象（Event Object）

事件对象是在**事件触发**的时候浏览器自动创建的对象，它包含与**该事件相关的信息和方法**

- `event.target`：事件的目标元素，即**触发该事件的元素。**
- `event.currentTarget`：当前**正在处理事件的元素**，可能与目标元素不同。
- `event.type`：**事件的类型**，例如 "click"、"mouseover"、"keydown" 等。
- `event.preventDefault()`：**阻止事件的默认行为**，例如阻止表单提交或超链接跳转。
- `event.stopPropagation()`：**阻止事件的冒泡**，即停止事件向父元素传播。

-----

### 9.动态绑定class style

通过**对象语法**和**数组语法**进行动态绑定：

:class="XXX" , XXX可以是字符串，数组，对象

:style="[a,b]", a,b是样式对象

:style="{fontSize:XXX}",XXX是动态值

字符串的写法是适用于：类名不确定，个数不确定，名字也不确定

数组的写法适用于：绑定多个样式，个数不确定，名字也不确定

对象写法适用于：绑定多个样式，个数确定，名字确定，不确定用不用

> ```vue
> //对象
> <div v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
> 
> data: {
>   isActive: true,
>   hasError: false
> }
> ```
>
> ```vue
> //数组
> <div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
> 
> data: {
>   activeClass: 'active',
>   errorClass: 'text-danger'
> }
> ```
>
> ```vue
> //对象
> <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
> 
> data: {
>   activeColor: 'red',
>   fontSize: 30
> }
> ```
>
> ```vue
> //数组
> <div v-bind:style="[styleColor, styleSize]"></div>
> 
> data: {
>   styleColor: {
>      color: 'red'
>    },
>   styleSize:{
>      fontSize:'23px'
>   }
> }
> ```
>
> 

-----

### 10.过滤器

**未改变原来的数据**,而是产生新的数据

局部过滤器**优先于**全局过滤器被调用

可以接受**额外的参数**,多个过滤器可以**串联**

**使用方法：**

```js
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

**使用场景：**

文本格式化，时间格式化

-----

### 11.生命周期

**生命周期钩子：**在组件的生命周期（创建，更新，销毁）的**各个阶段调用的函数**

**生命周期：**Vue实例从创建到销毁的过程，就是生命周期。 

**Vue生命周期总共可以分为8个阶段：**创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期

![](E:\Front\八股文\My八股文\八股图\生命周期.png)

实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作 

挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 
接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 
接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情... 
当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿 
当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom 
当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等 
组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以 

-----

### 在哪个生命周期内调用异步请求？

可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面 loading 时间；
- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

-----

### 在什么阶段才能访问操作DOM？

在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM

-----

### 12.NextTick

​		 Vue 是异步渲染, data改变后，DOM不会立即渲染，而是等同一事件循环中的所有数据变化完成之后，再统一进行渲染。所以修改完数据，立即在方法中获取DOM，获取的仍然是未修改的DOM。

 **$nextTick的作用是**：该方法会**在DOM渲染之后被触发**，以**获取最新的DOM节点**，就解决了异步渲染获取不到更新后DOM的问题了。 允许你在**下一次 DOM 更新周期之后**执行回调函数，确保在视图更新后再执行你的操作

**$nextTick的原理：**$nextTick本质是返回一个Promise 

**应用场景：**

​	在钩子函数created()里面想要获取操作Dom，把操作DOM的方法放在$nextTick中

​	如果想要在修改数据后立刻得到更新后的`DOM`结构，可以使用`Vue.nextTick()`

-----

#### 14.MVVM模型

**数据驱动视图**

**Model:**数据模型，代表应用程序的**数据**和**业务逻辑**

**View :**代表视图，负责**数据的展示, 模板代码**

**ViewModel:**负责监听Model 中**数据的改变**并且**控制视图的更新**，处理**用户交互操作**；

​	Model 和 View 并**无直接关联**，而是**通过 ViewModel 来进行联系的**

​	Model 和ViewModel 之间有着**双向数据绑定的联系**。

​	因此当 Model 中的数据改变时会触发View 层的刷新，

​	View 中由于**用户交互操作而改变**的数据也会在Model 中同步。

​	这种模式实现了 **Model 和View 的数据自动同步**，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。

-----

**15.MVVM 的优缺点?**

**优点:**

1. **分离关注点**：数据逻辑和视图逻辑分离，使代码更具可读性、可维护性和可测试性。

2. **双向数据绑定：**MVVM模式通过**数据绑定**实现了模型和视图之间的双向同步。当模型中的数据发生变化时，视图会自动更新；反之，当用户在视图中进行操作时，模型中的数据也会随之更新。**这减少了手动操作DOM的工作量，提高了开发效率。**

3. **可复用性：**使得视图可以被复用于不同的视图模型

4. **开发效率**：由于MVVM模式中的数据绑定和自动更新机制，**开发者可以更专注于业务逻辑的实现**，而不用过多关注视图的更新和同步问题。这提高了开发效率，并减少了开发中的出错机会。

**缺点:**

1. **难调试:**因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得⼀个位置的Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写.在 View 的模版当中的，这些内容是**没办法去打断点debug** 的.
2. **性能问题**:**频繁的数据绑定和自动更新**可能会导致性能下降，特别是在处理大规模数据或复杂视图时。

-----

### 16.MVVM中data-binging机制的实现原理

主要是通过Object.defineProperty()方法**对数据的劫持和监听**，其**set的内部属性可以起到监听的作用**，当发现字段的值发生了改变，在set内部属性中就会**触发函数，去更新视图**

----

### 17.组件间通信

**1.父子组件通信**

​	**props：**

​		父组件在使用**子组件标签中通过字面量来传递值**

​		子组件设置**props属性**，**定义接收父组件传递过来的参数**

​		单向数据流  子组件可能被多个父组件进行复用。props是只读的，不可以被修改，所有的修改都会失效和警告。想修改进行拷贝，注意深浅拷贝的问题，

​	**ref：**

​		父组件在使用子组件的时候设置ref，**通过ref来获取子组件的实例**，通过实例就能拿到对应的属性或方法

​	**插槽：**

**2.子父组件通信**

​	**$emit 触发自定义事件：**

​		子组件中，用**$emit触发自定义事件**，第一个参数是**事件名**，第二个参数是要**传递的值**

​		父组件中，为**子组件绑定一个自定义的事件**，可以用@/on，并且**回调函数存在于父组件中**

**3.任意间，兄弟间组件通信**

​	**全局事件总线：**

​		在**main.js**入口函数中，**实例化vue**的时候，在**beforeCreate**中**注册全局事件总线$bus**，将**当前Vue实例作为事件总线，将其挂载到vue原型上**，从而在整个应用中都可以通过`this.$bus`访问到事件总线，本质是一个对象

​	使用：A组件想接受数据,则在A组件中给**$bus绑定自定义事件**,事件的**回调留在A组件自身,**即:**监听并响应该事件**

​					B组件提供数据，**在B组件中触发自定义事件**

​	**Vuex：**

​		相当于一个**用来存储共享变量的容器**

​		主要包括state,actions,mutations,getters和modules 5个要素

​		主要流程：组件通过dispatch到 actions，actions是异步操作，再actions中通过commit到mutations，mutations再通过逻辑操作改变state，从而同步到组件，更新其数据状态,而getters相当于组件的计算属性对,组件中获取到的数据做提前处理的.再说到辅助函数的作用.

-----

### vuex如何实现数据持久化（即刷新后数据还保留）？

本地存储(localStorage,sessionStorage)

利用第三方封装好的插件，例如：vuex-persistedstate

-----

### 18.EventBus的优缺点

**优点：**

​	解决了**多层组件之间繁琐的事件传播**，使用原理十分简单，代码量少。

​	适合**业务简单**，**组件传递数据较少的项目**，大型项目业务复杂的还是尽量使用VueX

**缺点：**

​	**vue是单页应用**，如果你在某一个页面**刷新**了之后，与之相关的**EventBus**会被移除，这样就导致业务走不下去。	如果页面中有反复操作的业务，**EventBus在监听的时候就会触发很多次**，需要好好处理EventBus在项目中的关系。

​	在vue页面销毁时，同时移除EventBus事件监听。

-----

### 19.slot 插槽

​	父组件向子组件指定的位置插**入html结构**，也是组件间通信的一种方式

​	父组件使用**Category包裹住传递的结构**，子组件中使用**slot做占位**

分类：

1. 默认插槽:
2. 具名插槽: 父组件**指明要放入子组件的哪个插槽中**
3. 作用域插槽: scope用于父组件往子组件插槽中放html结构**接受子组件的数据**，**数据在组件的自身**，但是**数据生成的结构需要组件的使用者决定**

-----

### 20.动态组件

​	动态组件允许你**根据不同的条件或事件**动态地**切换**组件的显示。

​	通过使用动态组件，你可以根据需要在**同一个位置渲染不同的组件。**

​	Vue提供了`<component>`元素作为动态组件的容器，你可以将需要动态渲染的组件包裹在`<component>`中，并通过动态绑定`is`属性来指定要渲染的组件。

-----

### 21.异步组件

在Vue中，异步组件（Async Components）允许你按需加载和渲染组件，用于优化应用的性能和加载速度

-----

### 22. Keep-alive缓存路由组件

得分点 缓存组件、条件缓存、路由配合条件缓存、不重新加载、activated、deactivated

**作用：**

​	缓存组件，提升性能，避免重复加载一些**不需要经常变动且内容较多的组件**。

**使用方法：**

​	使用`<keep-alive>`标签对需要缓存的组件进行包裹，默认情况下被`<keep-alive>`标签包裹的组件都会进行缓存

​	提供 include 和 exclude 属性，两者都支持字符串或正则表达式, exclude 的优先级比 include 高；

​			include：只有名称匹配的组件会被缓存

​			exclude ：任何名称匹配的组件都不会被缓存

​	一般**结合路由和动态组件**一起使用，用于缓存组件，路由配合使用：在路由中添加**meta**属性。 使用keepalive：true导致组件不重新加载，也就不会重新执行生命周期的函数，如果要解决这个问题，就需要两个属性进入时触发：activated ，退出时触发：deactivated 

​	对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated

**适用的场景：**

​	**多个静态的tab页切换**

-----

### 23.keep-alive 中的生命周期哪些?

设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（`activated`与`deactivated`）：

1. 首次进入组件时：`beforeRouteEnter` > `beforeCreate` > `created`> `mounted` > `activated` > ... ... > `beforeRouteLeave` > `deactivated`

2. 再次进入组件时：`beforeRouteEnter` >`activated` > ... ... > `beforeRouteLeave` > `deactivated`

> - `activated`：在**组件被激活时调用**。当组件被切换到**可见状态**时，该钩子函数会被触发。
> - `deactivated`：在**组件被停用时调用**。当组件从可见状态切换到不可见状态时，该钩子函数会被触发。
> - `beforeRouteEnter`：在**组件被缓存且激活之前调用**。在组件首次被缓存时，该钩子函数会被触发。
> - `beforeRouteLeave`：在**组件被缓存且停用之前调用**。在组件即将被缓存之前，该钩子函数会被触发

-----

### 24.mixin 抽离组件公共部分

​	将组件中**公共的数据、方法以及生命周期钩子**抽离出来保存在一个mixin.js中

​	组件与混入的对象有**同名选项**的时候,可以**合并**,发生冲突的时候**以组件优先**

​	同名的**生命周期钩子**可以合并为一个**数组**,都会被**调用**,**混入对象的钩子会在组件自身钩子之前调用**

**存在的一些问题**

1. 变量**来源不明确**，不利于阅读
2. 多mixin可能会**造成命名冲突**
3. mixin和组件可能出现**多对多的关系，复杂度较高**

-----

### 25.路由的基本概念

1. 后端路由
   概念：根据不同的用户URL请求，返回不同的内容
   本质：**URL请求地址**与**服务器资源**之间的对应关系

2. 前端路由
   概念：根据不同的用户事件，显示不同的页面内容
   本质：**用户事件**与**事件处理函数**之间的对应关系

-----

### 路由组件与非路由组件的区别？

1. 路由组件 `pages|views`，非路由组件在`components`
2. 路由组件一般需要在`router`文件夹中的`index.js`文件中配置路由规则，非路由组件在使用的时候，一般都是以标签的形式使用
3. 注册完路由，不管是路由组件还是非路由组件，身上都有 `$route,$router`属性
4. `$route：`一般获取路由信息【路径，`query`，`params`等等】，其实非路由组件当中的`this.$route`就是当前显示的路由组件的一些信息，比如路径，`name`，`meta`等等
5. `$router：`一般进行编程式导航进行路由跳转`【push | replace】`

> $router.push()  $router.replace() $router.go() $router.beforeEach()

-----

### 路由跳转的两种方式

- 声明式导航：`router-link` 
- 编程式导航 ：`this.$router.push({})| replace({})` 声明式导航能做的编程式都能做，而且还可以处理一些业务

-----

### query和params的区别

**query：**

  不属于路径中的一部分，不需要占位，`$route.query`来接收参数

**params：**

​	属于路径的一部分，配置路由的时候需要占位，在对象写法中，不能使用path配置项，必须使用name配置！！！`$route.params.id`接收参数

**1. 参数位置：**

- `query`参数出现在URL的查询字符串中，以`?`符号开始，多个参数使用`&`进行连接。例如：`/path?param1=value1&param2=value2`。
- `params`参数出现在URL的路径中，作为路径的一部分。例如：`/path/:param1/:param2`。

**2. 匹配规则：**

- `query`参数在路由匹配时不参与路由的精确匹配，不会影响路由的匹配结果。
- `params`参数在路由匹配时参与路由的精确匹配，路由会根据`params`的值来进行匹配。

**3. 传递方式：**

- `query`参数可以通过URL直接传递，也可以通过编程式导航中的`$router.push()`或声明式导航中的`<router-link>`进行传递。
- `params`参数一般通过编程式导航中的`$router.push()`或`$router.replace()`方法进行传递。

**4. 使用场景：**

- `query`参数适合传递一些可选的参数，如**搜索关键词、排序方式**等。
- `params`参数适合传递一些必要的参数，如**文章ID、用户ID**等。

**5. 获取方式：**

- `query`参数可以通过`$route.query`或`this.$route.query`来获取。
- `params`参数可以通过`$route.params`或`this.$route.params`来获取。

-----

### 路由组件能不能传递props数据？

**props：**让路由组件更方便的收到参数

**way1：**值为**对象**，该对象中的所有key-value都会以props的形式传给Detail组件

缺点：值是死的

```vue
{
	name："hello",
	path："welcome/:id/:title",
	component:Hello,
	props:{id：666,title:'offer'}
}
```

**way2：**值为**布尔值**，若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传给Detail组件
缺点：只能传params参数的，query参数不能用这个

```Vue
{
	name："hello",
	path："welcome/:id/:title",
	component:Hello,
	props:true
}
```

**way3：**值为**函数**，该函数返回的对象中每一组key-value都会通过props传给Detail组件，最常用的，函数会受到参数，这个参数就是组件身上的`$route`，我们可以通过它来获取query或者params里面的东西，然后传过去

```Vue
{
	name："hello",
	path："welcome/:id/:title",
	component:Hello,
	props($route){
		return {
			id:$route.params.id,
			title:$route.query.title
		}
	}
}
```

```Vue
<ul>
 <li>消息编号:{{id}}</li>
 <li>消息标题:{{title}}</li>
</ul>

<script>
 export defalut{
     name:'hello',
     props:['id','title']
 }
</script>
```

-----

### 路由传递参数(对象写法) path是否可以结合params参数一起使用？

​		不可以，路由跳转传参的时候，对象的写法可以是`name`，`path`的形式，但需要注意的是，`path`这种写法不能与`params`参数一起使用

-----

### 如何指定params参数可传可不传？

在配置路由的时候，给params占位 的后面加上`?`，代表可传递也可以不传递，不然URL有问题

-----

### params参数可传递也可以不传递，但是如果传递是空串，如何解决？

使用undefined解决

```js
params:{
	keyWord:'' || undefined,
},
```



-----

### 26.Object.defineProperty的缺点及其优化

**缺点:**

1. **性能开销:**深度监听,需要递归到底,一次性的计算很大,需要**遍历对象的每个属性，并在每个属性上设置 getter 和 setter**。当有大量属性需要劫持时，这个过程可能会导致性能下降。
2. **无法监听属性的添加和删除: **其只能监听到属性值的变化,无法监听到属性的添加和删除操作,**无法实现对整个对象的监听**(`Vue.set` / `Vue.delete`)
3. **不支持对数组和对象的监听:**只能监听**对象属性值**的变化，而无法直接**监听数组和对象的变化**。需要额外的处理。

**优化:** 

1. Proxy **直接代理整个对象而非对象属性**，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。
2. Proxy 可以**监听数组的变化**。

-----

### Proxy 与 Object.defineProperty 优劣对比

**Proxy 的优势如下:**

- Proxy 可以直接**监听对象而非属性；**
- Proxy 可以直接**监听数组的变化**；
- Proxy **有多达 13 种拦截方法,**不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
- Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
- Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

**Object.defineProperty 的优势如下:**

- 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。

-----

### 27.数据更新了但是页面没有变化，为什么？怎么解决？

1. **没有使用响应式属性:**Vue只能对使用了响应式属性的数据进行跟踪和更新，如果数据是在Vue实例创建之前添加的，或者是动态添加的非响应式属性，那么Vue无法监听到数据的变化，导致页面没有更新。
2. **没有正确使用Vue的更新机制：**Vue会在数据变化时通过虚拟DOM比对来更新页面，但有时候我们可能没有使用Vue提供的更新机制。比如直接使用`array[index] = value`来更新数组元素或使用`object.property = value`来更新对象属性，这样的更新方式是无法被Vue检测到的。正确的做法是使用Vue提供的响应式方法，比如`Vue.set`或`Array.prototype.splice`来更新数组，以及使用`Vue.set`或`Object.assign`来更新对象属性。
3. **异步更新问题：**Vue的数据更新是异步执行的，当多次对同一个数据进行修改时，Vue会将这些更新操作合并成一次更新以提高性能。但在某些情况下，由于异步更新的机制，可能会导致数据更新了但页面没有立即更新。这通常发生在Vue的生命周期钩子函数、事件处理函数或异步操作中。解决这个问题可以使用`Vue.nextTick`方法来在下一个DOM更新周期后执行回调函数，确保在数据更新后再进行操作

**解决方案：**

- 如果为对象添加少量的新属性，可以直接采用`Vue.set()`/六种数组原型上的方法`push(),pop(),shift(),unshift(),splice(),sort()`
- 如果需要为新对象添加大量的新属性，则通过`Object.assign()`创建新对象
- 如果你实在不知道怎么操作时，可采取`$forceUpdate()`进行强制刷新 (不建议)



- 确保所有需要被Vue跟踪的数据都是响应式的，使用`data`选项来定义初始数据。
- 使用Vue提供的响应式方法来更新数组和对象属性，确保数据变化能被Vue检测到。
- 在需要等待DOM更新后再执行的代码中，使用`Vue.nextTick`来确保在正确的时机进行操作

-----

### 28.虚拟DOM

##### 是什么？

​	用一**个原生的JS对象**去描述一个DOM节点,实际上它只是对真实 DOM 的一层抽象

##### 为什么需要虚拟DOM？

1. **数据驱动的更新**：Vue 的数据响应式系统可以追踪数据的变化，并自动更新相应的视图，比如一个组件要牵扯到100个DOM元素，我改动了组件中的某一个数据，那么100个元素里面，哪个元素会有变化，她搞不清楚，此时他就会全部的更新，如果是真实地DOM，操作真实地dom非常地昂贵。

   虚拟 DOM 在这一过程中发挥重要作用。当数据发生变化时，Vue 会通过比较前后状态的虚拟 DOM 树的差异，确定需要进行的实际 DOM 更新操作。这种精确的更新机制避免了对不受影响的 DOM 元素进行不必要的操作，提高了性能。

2. **跨平台兼容性**：Vue 的虚拟 DOM 不仅在浏览器环境中发挥作用，还可以在其他平台上使用，如小程序、移动端等。通过在不同平台上实现对虚拟 DOM 的支持，Vue 使开发人员能够使用相同的组件和代码，在不同的平台上实现一致的用户界面和功能。这种跨平台的能力提高了开发效率和代码复用性。

##### **虚拟DOM的思想**：

​		数据发生变化时，先通过对比新旧虚拟DOM的差异，然后将这些差异批量地应用到真实的DOM上，以减少对真实DOM的直接操作，提高性能。

**优点：**（虚拟DOM是如何提高应用程序性能的？）

1. **减少实际 DOM 操作**：直接操作实际的 DOM 是比较昂贵的操作，因为每次更新都会引起浏览器的重绘和重排。虚拟 DOM 可以通过对比前后状态的差异，最小化对实际 DOM 的操作，从而减少性能损耗。
2. **批量更新**：虚拟 DOM 可以收集一批更新操作，并一次性将它们应用到实际的 DOM 中。这样可以减少对实际 DOM 的读写次数，提高更新的效率。
3. **跨平台兼容性**：虚拟 DOM 是平台无关的，它可以在各种环境中运行，包括浏览器、移动端和服务器端。这使得 Vue 在多种应用场景中都能提供一致的开发体验。
4. **高效的 Diff 算法**：虚拟 DOM 使用高效的 Diff 算法来比较前后两个状态的差异，然后只更新需要变更的部分。这样可以减少不必要的 DOM 操作，提高渲染的效率。

**不一定提升性能**

​		**虚拟 DOM 的性能优势主要在于能够减少实际 DOM 的操作次数**。但是，如果应用程序本身的复杂度不高或者虚拟DOM的实现方式不够优秀，可能无法带来性能提升，甚至会引入额外的性能开销。

​		它的优势是在于 **diff 算法和批量处理策略**，将所有的 DOM 操作搜集起来，一次性去改变真实的 DOM ,但在首次渲染上，虚拟 DOM 会多了一层计算，消耗一些性能，所以有可能会比 html 渲染的要慢

-----

### 30. 为什么处理DOM慢，而处理对象快？

1. DOM 操作会**引起页面的重绘和重排**
2. DOM 结构是树形结构，它需要通过遍历来查找和访问节点。当 DOM 结构非常庞大时，遍历的时间成本也会相应增加。
3. DOM 操作涉及到网络请求和 I/O 操作，这些操作通常是异步执行的，需要等待操作完成后才能进行下一步操作。这也会影响到 DOM 操作的性能。

相比之下，JS处理对象要快一些的原因主要有以下几点：

1. JS 引擎通常会将**对象存储在堆内存中**，并使用指针来访问它们。因为堆内存是连续的，所以访问对象的时间复杂度是**常数级**别的，而不会像 DOM 遍历那样需要花费大量时间。
2. JS 引擎在**对对象进行操作时**，通常会将**其存储在寄存器或缓存**中，这样可以大大提高访问速度。
3. JS 的对象**通常比DOM结构更小**，这意味着访问和操作对象所需的数据量更少，也更容易缓存。

总之，浏览器处理 DOM 很慢，而 JS 处理对象很快的原因主要在于 **DOM 操作涉及到页面布局和渲染等复杂的计算和 I/O 操作**，而 JS 操作对象通常**只需要访问内存中的指针，并且对象的大小和操作数据量都比 DOM 结构小**。

-----

### 29.diff算法

**基本思路：**

​		递归地比较新旧虚拟DOM树的节点，按照**节点类型、属性和子节点**等信息进行比对。只比较同一层级，不跨层比较。

**对比规则：**

​	a.旧虚拟DOM中找到了新虚拟DOM相同的key

​		aa.若虚拟DOM中内容没变，直接使用之前的真实DOM

​		 bb.若虚拟DOM中内容变了，则生成新的真实的DOM，随后替换掉页面中之前的真实的DOM

​	b.旧虚拟DOM中未找到与新虚拟DOM相同的key

​		创建新的真实DOM，随后渲染到页面

-----

### 30.vue中key的作用和原理

key是给每一个vnode的唯一id，性能优化

**作用：**

**优化vue虚拟DOM的算法**

​		在更新DOM时，通过对比新旧节点的key值，可以最大程度的减少DOM的操作，提高页面渲染的性能.

**重用和就地复用：**

​	 在列表渲染中，Vue 会尽可能地复用已存在的 DOM 节点，而不是创建全新的节点。通过设置合适的 `key` 值，Vue 可以判断哪些节点是可以被重用的，从而减少不必要的 DOM 操作，提升性能。

**注意设置key的值：**不能是数组的下标，若对数组进行逆序的添加，删除等会破坏顺序操作，产生没有必要的真是的DOM更新。

-----

### 31.设置key值一定能提高diff效率吗？

不一定

提高 diff 效率的前提是**列表中的节点顺序相对稳定**，并且**节点的 `key` 值唯一且稳定不变**。

如果节点顺序经常变动或 `key` 值不唯一，那么设置 `key` 的效果将不明显，甚至可能导致 diff 的性能变差。

-----

### 33.vue的基本原理

----

### 34.SPA

SPA由一个**单独的HTML页面**组成，**所有的内容和资源都**在该页面中加载和渲染。页面切换时只更新部分内容，而不需要重新加载整个页面。

**优点：**

​		**流畅的用户体验**：无刷新的切换内容，提高用户体验

​		**减少服务器的压力：**由于页面初始化的时候项目依赖的资源**统一加载**了，所以后面切换页面就不需要向服务器发送请求

​		**前后端分离：**前端负责处理视图和交互，后端负责提供数据接口。

**缺点：**

​	**首屏加载速度慢：**由于SPA需要一次性加载所有必要的资源，初始加载时间可能较长，特别是当应用程序较大时。用户可能需要等待较长时间才能看到应用程序的初始界面

​	**SEO（搜索引擎优化）问题：**由于SPA**动态加载内容**，**搜索引擎爬虫**在**初始加载时可能无法获取完整的页面内容**，从而影响了网页在搜索引擎结果中的排名。需要采取额外的措施，如预渲染或服务器端渲染，以解决这个问题。

-----

### **35.SPA和MPA的区别**

MPA由多个HTML页面组成，每个页面对应一个不同的URL。每次页面切换都需要加载一个新的页面，页面之间的跳转需要通过超链接或服务器的重定向来实现。

|                 | 单页面应用（SPA）         | 多页面应用（MPA）                   |
| :-------------- | :------------------------ | ----------------------------------- |
| 组成            | 一个主页面和多个页面片段  | 多个主页面                          |
| 刷新方式        | 局部刷新                  | 整页刷新                            |
| url模式         | 哈希模式                  | 历史模式                            |
| SEO搜索引擎优化 | 难实现，可使用SSR方式改善 | 容易实现                            |
| 数据传递        | 容易                      | 通过url、cookie、localStorage等传递 |
| 页面切换        | 速度快，用户体验良好      | 切换加载资源，速度慢，用户体验差    |
| 维护成本        | 相对容易                  | 相对复杂                            |

-----

### 36.如何给SPA做SEO

**服务端渲染：**在服务端生成完整的HTML页面，并将其提供给搜索引擎爬虫

**设置合适的meta标签**

**使用合理的URL结构**

**静态化:**

(1) 使用**静态站点生成器**将**动态内容生成为静态HTML文件**。静态站点生成器会在构建过程中通过预先定义的模板和数据源生成静态HTML页面，并将其部署到**服务器上**。

(2)一种是通过WEB服务器的 `URL Rewrite`的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果

**使用`Phantomjs`针对爬虫处理**

-----

### 36.SPA首屏加载速度慢如何解决

浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容

**原因：**

​	**资源文件体积过大：**如果SPA应用的代码和资源体积过大，会导致**初始加载时需要下载的内容过多**，从而造成加载速度慢。

​	**依赖过多：**如果SPA应用依赖的外部库和组件过多，每个依赖都需要下载和加载

​	**加载资源不合理：**如果SPA应用将所有资源都一次性加载，或者资源是否重复发送请求去加载了会导致首屏加载速度慢。

​	**缓存策略不合理：**如果SPA应用的资源没有正确地设置缓存策略，每次访问都需要重新下载资源，增加了加载时间。

​	**网络延迟：**		

**解决方案**

​	**路由懒加载**

​	**图片懒加载**

​	**图片资源的压缩**

​	**UI框架按需加载**

​	**静态资源本地缓存**

​	**组件重复打包**

​	**开启GZip压缩**

​	**使用SSR**

-----

### 37.双向数据绑定的原理

vue的双向绑定

1. 定义: 数据变化视图会自动更新，视图变化数据也会更新

2. 原理: **数据劫持** + **发布订阅者模式**

3. 实现：

   采用`Object.defineProperty()`对数据进行劫持来监听数据变化，并通过getter/setter方法对数据进行读写。

   其次vue通过发布订阅者模式，维护了一个订阅者数组，当数据发生改变时，vue会通知所有订阅者进行更新，因此当用户在页面上进行修改时。Vue会更新对应的数据，并通知所有订阅者更新视图，同时当数据发生变化时，Vue也会更新对应视图，通过这样的机制，Vue实现了双向绑定。

   订阅者是一个概念，它是用于管理更新视图的对象，当数据发生变化时，Vue会通知所有的订阅者进行更新。**每一个挂载到视图上的组件或者每一个watcher都可以被看作是一个订阅者，他们订阅了某一个数据的变化，并等待数据发生变化时进行更新，**订阅者是Vue实现双向数据绑定的关键组成部分

-----

### 38.Vue 中封装的数组方法有哪些，其如何实现页面更新

1. push：将元素添加到数组的末尾。
2. pop：移除数组的最后一个元素。
3. shift：移除数组的第一个元素。
4. unshift：将元素添加到数组的开头。
5. splice：从数组中移除或添加元素。
6. sort：对数组进行排序。
7. reverse：反转数组元素的顺序。

-----

### 39.子组件可以直接改变父组件的数据吗？

Vue 提倡单向数据流，即父级 `props` 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。

**如果子组件需要修改父组件的数据，可以通过以下方式实现：**

1. 使用事件触发：子组件通过 `$emit` 方法触发一个自定义事件，第一个参数是**事件名**，第二个参数是要**传递的值**。父组件中，为**子组件绑定一个自定义的事件**，可以用@/on，并且**回调函数存在于父组件中**
2. 使用 `v-model`：如果父组件传递给子组件的数据需要进行双向绑定，可以使用 `v-model` 指令。`v-model` 会自动创建一个名为 `value` 的 prop，并监听子组件的 `input` 事件来更新父组件的数据。
3. 使用 `.sync` 修饰符：Vue 提供了 `.sync` 修饰符，可以简化父子组件之间的双向绑定。通过在子组件中使用 `.sync` 修饰符绑定一个父组件的属性，并通过 `$emit` 触发一个带有 `.sync` 后缀的事件来更新父组件的数据。

-----

### 40.assets 和static 的区别

"assets" 目录中的静态资源**需要经过构建和处理**，而 "static" 目录中的静态资源则直接复制到输出目录中，**不经过构建过程**

-----

### 41.delete 和Vue.delete 删除数组的区别

`delete` 是用于**删除对象属性的操作符**,不会触发 Vue 的响应式更新机制

`Vue.delete` 是 Vue.js 提供的一个方法，用于**删除 Vue 实例**或**组件的响应式数组的元素**,并触发响应式更新。

-----

### 42.对vue组件化理解和插件有什么区别

组件 `(Component)` 是用来构成你的 `App` 的业务模块，它的目标是 `App.vue`

插件 `(Plugin)` 是用来增强你的技术栈的功能模块，它的目标是 `Vue` 本身

简单来说，插件就是指对`Vue`的功能的增强或补充

----

### 43.Vue 子组件和父组件执行顺序

**父组件的生命周期钩子函数先于子组件的生命周期钩子函数执行**。

父组件先完成**创建和挂载**，然后才处理**子组件的创建和挂载**。

在整个过程中，子组件的生命周期钩子函数执行顺序与它们在父组件模板中的顺序一致。

加载渲染过程：

1. 父组件 beforeCreate

2. 父组件 created

3. 父组件 beforeMount

4. 子组件 beforeCreate

5. 子组件 created

6. 子组件 beforeMount

7. 子组件 mounted

8. 父组件 mounted

**更新过程：**

1. 父组件 beforeUpdate

2. 子组件 beforeUpdate

3. 子组件 updated

4. 父组件 updated

**销毁过程：**

1. 父组件 beforeDestroy

2. 子组件 beforeDestroy

3. 子组件 destroyed

4. 父组件 destoryed

----

### 44.路由的hash 和history 模式的区别

Vue-Router 有两种模式：hash 模式和 history 模式（常用）。默认的路由模式是hash 模式。

**URL展示**和**路由跳转方式**上不同

**URL展示：**

​		hash模式： 在 URL 中以 `#` 开头，\`#`及其后面的内容就是hash值，例如 `http://example.com/#/path`

​		history模式： 不包含 `#`，直接使用路径，例如 `http://example.com/path`

**路由跳转方式：**

​		**hash模式：**

​			当 URL 中的哈希值发生变化时，**不会导致浏览器向服务器发送请求**，而是触发浏览器的 `hashchange` 事件，相应的执行无刷新页面跳转，展示页面的信息。（hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器）

​		**history模式：**

​			使用的是传统的路由分发模式，即用户在输入一个 URL 时，**服务器会接收这个请求**，并解析这个URL，然后做出相应的逻辑处理。应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题（进行重定向之类的）

​			`history.back()，history.forward()，history.go()，history.pushState("追加历史记录")，history.replaceState("替换当前页面的历史记录")，history.onpopstate("监听历史记录信息的变化，执行相应的动作")`

-----

### 45.Vue-router 跳转和 location.href 有什么区别

**跳转的方式：**

​		使用 Vue Router 提供的**编程式导航**方法，例如 `router.push`、`router.replace`、`router.go` 等，或通过 `<router-link>` 组件来触发路由跳转

​		使用 JavaScript 中的 `location.href` 或 `location.replace` 方法进行页面跳转

**对应效果：**

​		通过 `Vue Router` 跳转时，**不会触发浏览器的刷新**，**页面内容会根据路由变化进行动态更新**，但整个页面的状态和 Vue 实例的状态会被保留，不会重新加载页面，因此可以实现单页应用（SPA）的效果。

​	通过 `location.href` **跳转会触发浏览器的刷新**，整个页面会重新加载。

-----

### 46.Vuex 和 localStorage 的区别

**数据存储方式：**

​		`Vuex`中的数据是在**内存中存储**的。

​		`localStorage`是以文件的形式存储在本地，可以将数据以键值对的形式，存储对象需要 JSON 的stringify 和parse 方法进行处理

**数据更新和响应：**

​		**Vuex中的数据是响应式的**，当数据发生变化时，与该数据相关的组件会自动更新。

​		localStorage存储的数据**不具备响应性**，即使数据发生变化，相关的组件不会自动更新。需要手动监听和处理数据的变化

**数据的持久性：**

​	`Vuex`中的数据是在**内存中存储**的，**只在当前会话期间保持有效**，刷新页面或关闭浏览器后数据会丢失。

​	`localStorage`**永久存储在浏览器中**。即使刷新页面或关闭浏览器，数据也会被保留。

-----

### 47.为什么要用 Vuex

两个子组件之间是无法直接进行通信的，一般需要借助父组件作为桥梁实现两个同级组件的通信，但是如果需要共享的数据较多，同时代码的逻辑，组件的嵌套又比较复杂，整个逻辑是十分的混乱，这个时候就需要一个有公共的地方存储数据，一个组件存，一个组件用的话就直接取

vuex就是是**实现了组件全局状态管理的一种机制**，通过**创建一个集中的数据存储的地方**，**达到了组件之间数据共享的作用**，vuex相当于状态管理工具，将数据存在一个公共的地方，谁要谁去取

-----

### 48.Vuex和单纯的全局对象有什么区别

1. 显式状态管理：Vuex 提供了一种显式的状态管理机制。通过定义状态、mutations、actions 等概念，Vuex 强制执行一种规范化的状态管理方式，使得状态的变更和使用变得**可追踪和可控**。而单纯的全局对象没有明确的规范，状态的变更和使用可能更加随意和混乱。
2. 响应式状态更新：Vuex 的状态是**响应式**的，当状态发生变化时，相关的组件会自动进行更新，无需手动触发更新，而全局对象中的状态变化需要手动处理更新。

-----

### 49.为什么 Vuex 的 mutation 中不能做异步操作？

确保**状态的变更**是**同步的**和**可追踪的**

vuex中所有状态变更的唯一途径是mutation，异步操作是通过action来提交mutation实现的

异步操作的时间是不确定的，如果在mutation中进行异步操作，无法保证状态变更的时机，可能导致状态的不一致性，无法很好的进行状态的追踪，给调试带来困难

-----

### 50.Vue项目中你是如何解决跨域的呢？

> 注意：跨域请求时浏览器的限制 你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。 浏览器发出请求 服务器也返回了只是浏览器在校验通过与否 没有浏览器参与无跨域问题出现

**是什么：**当前页面的某个接口请求的地址和当前页面的地址如果协议，主机，端口有一项不同，就说该接口跨域了



**原因：**跨域本质上是**浏览器基于同源策略**的一种安全手段

**解决方案：**

> **CORS（跨域资源共享 Cross-origin resource sharing）**：
>
> [跨域资源共享 CORS 详解 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2016/04/cors.html)
>
> 在**服务端设置响应头允许跨域实现** `res.setHeader('Access-Control-Allow-Origin','*');`， `res.setHeader('Access-Control-Allow-Methods','GET,PUT,OPTIONS,POST');`等相关字段，来指定运行跨域访问的规则
>
> > **中间件：**Node.js 中间件`cors` 
> >
> > **配置选项：** `cors` 中间件支持一些配置选项，你可以根据需要进行配置。以下是一些常用的选项：
> >
> > - `origin`: 指定允许访问的源。可以是字符串、正则表达式、函数或数组。例如：
> > - `methods`: 指定允许的 HTTP 方法。默认为 ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS']。
> > - `allowedHeaders`: 指定允许的请求头。默认为 ['Origin', 'X-Requested-With', 'Content-Type', 'Accept', 'Authorization']。
> > - `exposedHeaders`: 指定可以访问的响应头。
> > - `credentials`: 指定是否允许发送身份验证信息（如 cookies、HTTP 认证等）。默认为 false。
> > - `maxAge`: 指定预检请求的缓存时间，单位为秒。
> > - `preflightContinue`: 指定是否继续处理请求，而不是直接响应。默认为 false。
>
> > ##### 关于 cors 的 cookie 问题  想要传递 `cookie` 需要满足 3 个条件
> >
> > 1. 前端请求时在`request`对象中配置`"withCredentials": true`；这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 `withCredentials` 来进行传递 `cookie`.
> >
> > ```js
> > // 原生 xml 的设置方式
> > var xhr = new XMLHttpRequest();
> > xhr.withCredentials = true;
> > // axios 设置方式
> > axios.defaults.withCredentials = true;
> > ```
> >
> > 2. 服务端在`response`的`header`中配置`Access-Control-Allow-Credentials` 为 `true`
> >
> > 3. 服务端在`response`的`header`中配置`Access-Control-Allow-Origin`为非 `*`

> **JSONP（JSON with Padding）：**利用script标签可以跨域请求资源。
>
> **缺点：**只支持get，不支持post，不安全可能会遭受XSS攻击
>
> **流程：**
>
> 1. 在客户端声明一个回调函数，专门处理跨域获取服务器`JSON`格式的数据，函数形参为要获取目标数据(服务器返回的data)
> 2.  创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src，并将**函数名作为参数**拼接在`url`中发送给服务器，（可以通过问号传参:?callback=show）。
> 3. 服务器收到请求之后，把传递进来的**函数名**和它需要给你的**数据**拼接成一个字符串
> 4. 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作
>
> ​		（调用**该函数**，把数据外包**JS**，以**JSON**的形式回传给客户端，，从而实现跨域）
>
> ![JSON跨域](E:\Front\八股文\My八股文\八股图\JSON跨域.webp)

> **Proxy代理**：请求发送给**代理服务器**，静态页面和代理服务器是同源的，让代理服务器给后端发送请求，服务器和服务器之间不存在同源限制，这适合前后端分离的前端项目调后端接口
>
> 1. 如果是通过`vue-cli`脚手架工具搭建项目，我们可以通过`webpack`为我们起一个本地服务器作为请求的代理对象
>
>    通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不在一起仍会跨域
>
>    在`vue.config.js`文件，新增以下代码
>
>    ```js
>    module.exports = {
>        devServer: {
>            host: '127.0.0.1',
>            port: 8084,
>            open: true,// vue项目启动时自动打开浏览器
>            proxy: {
>                '/api': { // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的
>                    target: "http://xxx.xxx.xx.xx:8080", //目标地址，一般是指后台服务器地址
>                    changeOrigin: true, //是否跨域
>                    pathRewrite: { // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
>                        '^/api': "" 
>                    }
>                }
>            }
>        }
>    }
>    ```
>
>    ```js
>    axios.defaults.baseURL = '/api'
>    ```
>
> 2. `node`正向代理，服务端实现代理请求转发
>
>    > 正向代理是代理服务器，代理客户端，为客户端收发请求，需要主动设置代理服务器ip或者域名进行访问，由设置的代理服务器ip或者域名去访问目的服务器的内容并返回，使真实的客户端对目的服务器不可见
>
>    以`express`框架为例
>
>    ```js
>    var express = require('express');
>    const proxy = require('http-proxy-middleware')
>    const app = express()
>    app.use(express.static(__dirname + '/'))
>    app.use('/api', proxy({ target: 'http://localhost:4000', changeOrigin: false
>                          }));
>    module.exports = app
>    ```
>
> 3. 通过配置`nginx`反向代理
>
>    > 反向代理是代理目的服务器，不需要客户端做任何设置，使得真实的服务器对客户端不可见，代理服务器提供一个负载均衡的功能，代理服务器选一个目的服务器最快的发送请求；隐藏服务器真实的ip，提供安全保障
>
>    通过`nginx`配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。
>
>    先下载[nginx](https://link.juejin.cn/?target=http%3A%2F%2Fnginx.org%2Fen%2Fdownload.html)，然后将nginx目录下的nginx.conf修改如下，通过命令行`nginx -s reload`启动nginx
>
>    ```js
>    // proxy服务器
>    server {
>        listen       81;
>        server_name  www.domain1.com;
>        location / {
>            proxy_pass   http://www.domain2.com:8080;  #反向代理
>            proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
>            index  index.html index.htm;
>    
>            # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
>            add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
>            add_header Access-Control-Allow-Credentials true;
>        }
>    }
>    ```
>
>    ```js
>    // index.html
>    var xhr = new XMLHttpRequest();
>    // 前端开关：浏览器是否读写cookie
>    xhr.withCredentials = true;
>    // 访问nginx中的代理服务器
>    xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);
>    xhr.send();
>    
>    ```
>
>    ```js
>    // server.js
>    var http = require('http');
>    var server = http.createServer();
>    var qs = require('querystring');
>    server.on('request', function(req, res) {
>        var params = qs.parse(req.url.substring(2));
>        // 向前台写cookie
>        res.writeHead(200, {
>            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取
>        });
>        res.write(JSON.stringify(params));
>        res.end();
>    });
>    server.listen('8080');
>    console.log('Server is running at port 8080...');
>    ```
>
>    1
>


-----

### 52.重排和重绘的区别？什么情况下会导致，如何减少？

**区别：**

​		对 DOM的**大小，位置**进行修改后，浏览器会重新的计算元素的这些**几何属性**，叫**重排**

​		对 DOM的**样式进行修改后**，如颜色，背景颜色，浏览器不需要重新的计算元素的这些**几何属性**，直接绘制元素的新的样式，叫**重绘**

​	浏览器渲染页面时至少会触发一次重绘，重绘不一定需要重排，但是重排一定会触发重绘。

**重排触发的条件列举：**
	1.调整浏览器窗口大小
	2.改变字体
	4.内容导致的页面变化，比如input/textarea等
	7.对 DOM的大小，位置进行修改，删除DOM
	10.改变display属性

**重绘触发的条件列举：**
	1.颜色，阴影的属性修改
	2.text-align的修改
	3.:hover引起的颜色等不导致页面回流的style变动
	4.以上重排条件触发时会触发重绘

**减少重排和重绘：**
	1.尽量在DOM树的末端设置元素样式，改变class名来实现
	2.避免多次设置**内联样式**
	4.避免css的**javascript**
	5.在scroll/resize 等频发触发的事件中增加**函数节流**
	4.对于多次重排的元素，比如动画，使用**绝对定位**使其脱离文档流，不影响其他的元素

-----

### ~~53.vue要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？~~

- 路由方面：用户登录之后只能看到自己有权限访问的导航菜单，也只能访问自己有权限访问的路由地址。
- 视图方面，用户只能看到自己有权浏览的内容和有权操作的权限
- 在请求控制作为最后一道防线，请求控制作为兜底，越权请求将在前端被拦截

**接口按钮：**

​		接口权限一般采用jwt的形式来验证，没有通过的话返回401，跳转到登录页面重新进行登录

​		登录完拿到了token，将token存下来，通过axios请求拦截器进行拦截，在每次请求的时候头部携带token

**路由权限控制：**

​		初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验

​		动态添加路由，按需挂载

**菜单权限**

-----

### ~~54.说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？~~

-----

### 55.SSR解决了什么问题？有做过SSR吗？你是怎么做的？

​	SSR（服务器端渲染）是一种将**页面的渲染**过程从客户端转移到服务器端的技术。通过使用SSR，服务器可以在返回给客户端之前，将动态生成的页面内容渲染为完整的HTML

**（1）服务端渲染的优点：**

- 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；
- 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等

**（2) 服务端渲染的缺点：**

- 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，需要处于 Node.js server 运行环境；
- 更多的服务器负载

-----

### 56.vue3有了解过吗？能说说跟vue2的区别吗？

##### 响应性原理：

1. `vue2`采用`Object.defineProperty()`对数据进行劫持来监听数据变化，并通过getter/setter方法对数据进行读写。但是它会带来一些问题：

  - **性能开销:**深度监听,需要递归到底,一次性的计算很大,需要**遍历对象的每个属性，并在每个属性上设置 getter 和 setter**。当有大量属性需要劫持时，这个过程可能会导致性能下降。
  - **无法监听属性的添加和删除: **其只能监听到属性值的变化,无法监听到属性的添加和删除操作,**无法实现对整个对象的监听**(`Vue.set` / `Vue.delete`)（比如给Date对象新增一个person属性，那么person就不是响应性的）
  - **不支持对数组和对象的监听:**只能监听**对象属性值**的变化，而无法直接**监听数组和对象的变化**。需要额外的处理。

  vue2提供了vue.$set的方法来解决，但是这样终究页是不合理的

2. vue3引入了reflect和proxy的概念，利用proxy代理整个对象，得到一个proxy实例，在vue3中，这样的一个过程叫reactive方法，但是proxy只能代理复杂的数据类型的响应性，vue3还额外提供了ref的方法来处理简单数据类型的响应，通过.value去获取值

##### 内存消耗：

1. vue2中new出的实例对象，挂载了所有的属性和方法，无论有没有用，都会运行一遍，增加了内存的消耗
2. vue3用ES module按需引入，减少了内存消耗，减少了时间，优化了体验

##### API类型不同：

1. vue2使用**选项类型api**，选项型api在代码里分割了不同的属性：data,computed,methods等。
2. vue3使用**合成型api**，新的合成型api能让我们使用方法来分割，相比于旧的api使用属性来分组，这样代码会更加简便和整洁。

##### 定义数据变量和方法不同：

1. vue2是把数据放入data中，在vue2中定义数据变量是**data(){}** ，创建的方法要在**methods:{}** 中
2. vue3就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。使用以下三个步骤来建立反应性数据：
   - 从vue引入**reactive**；
   - 使用**reactive()** 方法来声明数据为响应性数据；
   - 使用setup()方法来返回我们的响应性数据，从而**template**可以获取这些响应性数据。

##### 生命周期钩子函数不同

1. vue3.x 生命周期在调用前需要先进行引入
2. 相比与vue2，少了beforeCreate 和created ，多了setup ，此外加了on

-----

### 57.防抖和节流

**防抖：**在一定时间内，频繁触发事件，只执行最后一次

**应用场景：**搜索框搜索输入  文本编辑器的保存

**代码思路：**利用定时器，每次触发**先清掉以前的定时器**

```js
function debounce(func, delay) {
  let timerId=null
  return function(...args) {
   	if(timerId) clearTimeout(timerId);
    timerId = setTimeout(() => {
      func.apply(this, args);
       timerId=null
    }, delay);
  }
}
```

**节流：**在一定时间内，频繁触发事件，只执行一次

**应用场景：**高频事件，鼠标滚动，resize事件 scroll事件

**代码思路：**利用定时器，**等待定时器执行完毕，才开启定时器**

```js
function throttle(func, delay) {
  let timerId = null;
  return function(...args) {
    if (timerId) return;
    timerId = setTimeout(() => {
      func.apply(this, args);
      timerId = null;
    }, delay);
  }
}
```

一般用lodash库来做

-----

### 事件循环？

[稀土掘金](https://juejin.cn/post/7242895029957001277)

1. JS是单线程，防止代码阻塞，把任务分为：同步和异步（定时器，ajax，事件绑定）

2. 同步任务给**js引擎执行**，异步代码交给**宿主环境**

3. 同步任务放到**执行栈**中，异步代码等待时机成熟送入**任务队列**排队

4. **执行栈执行完毕，去任务队列中看是否有异步任务**，有就送到执行栈执行，反复循环查看，这个过程是事件循环

-----

### 宏任务和微任务

JS把异步任务分为宏任务和微任务                                                                                                                                           

宏任务由**宿主环境**（浏览器，Node）发起的（script，定时器，I/O）

微任务由**JS引擎发起的任务**（nextTick（），Ascync/Await，Object.observe，Promise 其本身是同步的，then/catch的回调函数是异步的）

---

### 执行顺序

1. 同步代码

2. 微任务的异步代码

3. 宏任务的异步代码

-----

cookie，localStorage，sessionStorage的区别？

-----

### Promise  async和await？

1. 都是处理异步请求的方式 Promise  主要是解决回调地狱的问题

2. promise是ES6，async是ES7
3. async和await是**基于promise**实现的，它们都是**非阻塞性**的

**优缺点：**

1. promise返回的对象，我们要使用**then,和catch**去处理和捕获异常，书写方式是链式的，容易造成代码堆叠，不好维护；async await是通过**try catch**捕获异常的
2. **async await可以使得代码像同步一样**，只要遇到await就会立刻返回结果，然后再执行后面的操作，promise.then()返回，会出现**请求还没有返回，就执行后面的操作**

-----

### 你有对 Vue 项目进行哪些优化？

优化是一个比较大的话题，优化是一个不断提升的过程

一般我们要做的是代码优化和用户体验（和不同的产品有关系）

优化里面有一些共性的问题 还有一些特殊的问题

共性：图片懒加载，路由懒加载

特殊：

#### Web 性能优化辅助工具

**Lighthouse：**

> 用于评估网页的性能、可访问性、最佳实践和SEO等方面，生成详细的报告
>
> **性能评估**：首次内容渲染时间、完全加载时间、网络请求优化等方面的指标。
>
> **最佳实践**：合适的缓存策略、使用正确的图像格式、避免阻塞渲染的脚本
>
> **SEO：**页面的标题、描述、关键字等元数据是否正确设置

**Webpack**：

> 一个模块打包工具，可以对前端资源进行代码压缩、文件合并、懒加载等优化操作，减少资源的大小和数量。

**性能监测工具（Google Analytics、Pingdom）**

> 页面加载时间、首屏渲染时间等，帮助发现性能瓶颈和进行优化

#### 具体优化内容有

图片优化

> 小图使用**雪碧图**  图片使用**懒加载**  **webp代替其他格式**  **图片一定要压缩**
>
> 可以使用的img的srcset，根据不同分辨率显示不同尺寸图片，这样既保证显示效果，又能节省带宽，提高加载速度

css

> css写在头部  避免css表达式  移除空置的css规则  避免行内style样式

js优化

> js写在body底部   js用defer放在头部，提前加载时间，又不阻塞dom解析
>
> script标签添加crossorigin，方便错误收集

渲染优化

> 动**画元素一定要absolute，脱离文档流，不影响其他元素**。动画不要用left，top等操作，要使用transform和opacity，同时开启渲染层(will-change或translate3d(0,0,0))
>
> **尽量减少reflow和repaint**，涉及到样式，尺寸，节点增减的操作，都会触发reflow和repaint。
> 2.避免多次设置**内联样式**
> 4.避免css的**javascript**
> 5.在scroll/resize 等频发触发的事件中增加**函数节流**

首屏优化

> 代码分离，将首屏不需要的代码分离出去
>
> 服务端渲染或预渲染，加载完html直接渲染，减少白屏时间

vue优化

> - v-if 和 v-show 区分使用场景
> - computed 和 watch  区分使用场景
> - v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
> - 图片资源懒加载(vue-lazyload )
> - 路由懒加载
> - 第三方插件的按需引入
> -  keep-alive缓存组件，保持原显示状态

SEO优化

> 添加各种meta信息
>
> 预渲染
>
> 服务端渲染

webpack打包优化

> 

**1）代码层面的优化**

- v-if 和 v-show 区分使用场景
- computed 和 watch  区分使用场景
- v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
- 图片资源懒加载(vue-lazyload )
- 路由懒加载
- 第三方插件的按需引入
- 服务端渲染 SSR or 预渲染
- 长列表性能优化(Object.freeze 方法来冻结一个对象)
- 事件的销毁
- 优化无限列表性能

**（2）Webpack 层面的优化**

- Webpack 对图片进行压缩
- 减少 ES6 转为 ES5 的冗余代码
- 提取公共代码
- 模板预编译
- 提取组件的 CSS
- 优化 SourceMap
- 构建结果输出分析
- Vue 项目的编译优化

**（3）基础的 Web 技术的优化**

- 开启 gzip 压缩
- 浏览器缓存
- CDN 的使用
- 使用 Chrome Performance 查找性能瓶颈

[优化详解](https://juejin.cn/post/6844903913410314247#heading-1)

-----

### scoped 是如何实现样式穿透的？

引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除 scoped 属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透 scoped。

**方法一**

使用 ::v-deep 操作符( >>> 的别名  **深度选择器**)

如果希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用 >>> 操作符：

```xml
<style scoped>

    .a >>> .b { /* ... */ }

</style>
```

上述代码将会编译成：

```css
.a[data-v-f3f3eg9] .b { /* ... */ }
```

后面的类名没有 data 属性，所以能选到子组件里面的类名。

有些像 Sass 之类的预处理器无法正确解析 >>>，所以需要使用 ::v-deep 操作符来代替。

**方法二**

定义一个含有 scoped 属性的 style 标签之外，**再定义一个不含有 scoped 属性的 style 标签**，即在一个 vue 组件中定义一个全局的 style 标签，一个含有作用域的 style 标签：

```xml
<style>

/* global styles */

</style>



<style scoped>

/* local styles */

</style>
```

此时，我们只需要将修改第三方样式的 css 写在第一个 style 中即可。

**方法三**

上面的方法一需要单独书写一个不含有 scoped 属性的 style 标签，可能会造成全局样式的污染。

更推荐的方式是在组件的外层 DOM 上添加唯一的 class 来区分不同组件，在书写样式时就可以正常针对针对这部分 DOM 书写样式。

-----

### 路由守卫

Vue的路由守卫主要分为全局守卫和路由独享守卫：

1. 全局守卫：
   - `beforeEach`：在**每个路由切换前**都会执行，
   - `afterEach`：在**每个路由切换后**执行
2. 路由独享守卫：
   - `beforeEnter`：特定路由切换前后调用
3. 组件内守卫：
   - `beforeRouteEnter`：通过路由规则，进入给组件时被调用
   - `beforeRouteUpdate`：在当前路由被复用时调用，例如从 `/user/1` 切换到 `/user/2`。
   - `beforeRouteLeave`：通过路由规则，离开给组件时被调用

-----
