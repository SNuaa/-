## Vue 超长列表渲染性能优化实战

#### 零、背景

实验数及论文的实验结果需要对外展示的时候，过长的列表容易造成卡顿影响性能，因此，我针对列表渲染这块进行了优化

----

#### 一、长列表的优化策略

- 分片渲染（通过浏览器的事件循环机制，分割渲染时间）
- 虚拟列表（只渲染可视区域）

-----

#### 二、进程与线程

- **定义：**进程是系统进行**资源分配和调度**的一个独立单位，一个进程包含多个线程
- **注意：**人们常说的JS是单线程，其实是**JS的主线程是单线程**（在代码的执行过程中，可以创建单线程，同步代码执行完会去执行异步代码）

> **为什么JS必须是单线程的？**
>
> ​	一个**线程**在某个DOM节点上添加内容，另一个**线程**删除这个节点的内容，会产生矛盾
>
> **为什么要有异步的任务？**
>
>   ​	JavaScript中的异步任务允许在**执行耗时操作**、**处理IO操作**、**处理事件和数据**时，提高程序的性能和响应性，同时**避免阻塞**整个应用程序  比如等着定时器时间到了再去执行，等着点击事件点击了再去执行吧

-----

#### 三、渲染进程

- JS引擎线程（执行JS脚本）
- GUI渲染线程
- 事件触发线程（EventLoop轮询处理线程）
- 事件（onclick），定时器，ajax（xhr）（独立线程）

> 注意：GUI 渲染线程和 JS 引擎线程是互斥的，所谓的 JS 是单线程的，就是指这条共享的主线程。

-----

#### 四、浏览器中的EventLoop

![](E:\Front\八股文\My八股文\八股图\eventloop.png)

> 1. JS是**单线程**，防止代码阻塞，把任务分为：**同步和异步**
> 2. 同步代码交给**JS引擎**去执行，异步代码交给**宿主环境（浏览器，Node）**
> 3. 同步代码放入**执行栈**中，异步代码等待时机成熟送入**任务队列**排队
> 4. **执行栈执行完毕，去任务队列中看是否有异步任务**，有就送到执行栈执行，反复循环查看，这个过程是事件循环

> **宏任务和微任务**
>
> 1. JS把异步任务分为**宏任务**和**微任务**                                                                                                                                                                                                                
> 2. 宏任务由**宿主环境**（浏览器，Node）发起的（**script，定时器，I/O**）
>
> 3. 微任务由**JS引擎发起的任务**（process.nextTick(node)，Ascync/Await，Object.observe，Promise 其本身是同步的，then/catch的回调函数是异步的）

> **执行的顺序**
>
> 1. 执行同步代码
> 2. 处理微任务
> 3. 渲染页面
> 4. 处理宏任务
> 5. 重复

> **注意：**
>
> 1. 一次 Eventloop 循环会处理**一个宏任务**和**所有这次循环中产生的微任务**。
> 2. **GUI的渲染时机**是在执行宏任务之前

-----

#### 五、分片渲染

##### 1、简单的长列表渲染

我们先**写一个有 10000 条简单数据的列表**，并打印时间，注意，这个时间是 js 语句执行的时间，而不是浏览器渲染的时间。

```js
<ul id="list"></ul>
<script type="text/javascript">
   //新版本浏览器的优化，当js执行完后会一并的插入到页面中
  const time = Date.now()
  for (let i = 0; i < 100000; i++) {
    const li = document.createElement('li')
    li.innerText = i
    list.appendChild(li)
  }
  console.log(Date.now() - time) // 160 JS引擎执行的时间
</script>
```

为了获得浏览器的渲染时间，根据上面的 EventLoop 可知，每次 GUI 渲染完都会执行一个宏任务，所以我们可以在后面添加一个定时器（宏任务），渲染完成后执行得到渲染时间。

```js
setTimeout(() => {
  console.log(Date.now() - time)
}, 0) // 2800 渲染时间
```

可以看到，js 执行时间为 160 ms，加上渲染总共用了 2801 ms。在渲染完成前页面一直是空白的加载状态，这是因为新版本的浏览器做了优化，会等待 for 循环执行完毕后再将 dom 节点插入到页面中，避免了频繁的重排和重绘。

##### 2、分片优化

因为 `requestAnimationFrame` 或定时器是一个宏任务，所以每执行一次 **GUI 渲染后**就执行一次相关的回调，**回调中实现了每次添加 50 个 li 节点，从而达到了分片加载的目的**。现在加载时间则如下：

```js
const time = Date.now()
/**
 * index: 记录循环到哪了
 * id: 往 li 里添加的内容
 */
let index = 0, id = 0
function load() {
  index += 50
  if (index < 10000) {
    requestAnimationFrame(() => {//用 requestAnimationFrame(也是宏任务)代替了setTimeout，性能更好点
      const fragment = document.createDocumentFragment() // IE 浏览器需要使用文档碎片，一般可不用
      // //先渲染50个 等待渲染完毕之后，在渲染50个
      for (let i = 0; i < 50; i++) {
        //现在的浏览器会自动地识别 合并DOM操作
        //但是老的浏览器不会  需要使用文档碎片 提高性能
        const li = document.createElement('li')
        li.innerText = id++
        fragment.appendChild(li)
      }
      list.appendChild(fragment)
    })
    load()
  }
}
load()
console.log(Date.now() - time)
setTimeout(() => {
  console.log(Date.now() - time)
})
```

与分片加载之前对比，确实快了许多。但这种方案有个问题：**会导致页面的 dom 元素过多，依旧容易造成卡顿。**

-----

#### 六、虚拟列表（只渲染当前的可视区域）

虚拟列表优化依据列表每一项（item）的高度是否为固定值分为两种情况：

##### **给组件传递三个值：**

- `size`：每一项的高度
- `remain`：希望展示几条数据
- `items`：列表的数据

##### **VirtualList组件有三个部分：**

`viewport`：最外层容器区域。高度固定超出区域出现滚动条。 `height：size*remain`

`scrollBar`：滚动条，列表应该有的高度区域，即就是列表如果全部渲染的总高度。因为只渲染`remian`指定的条数的数据，就会导致没有滚动条或者滚动条无法起到预告总的列表长度的功能，所以需要一个高度为列表总长度的`div`让滚动条正确的显示。

`scroll-list`：要展示的内容。展示的数据应该是总数据的一部分，展示的数据`item`还得传给父组件,在父组件进行使用，这里用到了插槽。

##### 6.1 `item`高度固定

1. **挂载**：算出`viewport`的高度，`scrollBar`的高度

```js
this.$refs.viewport.style.height = this.remain * this.size + "px";
this.$refs.scrollBar.style.height = this.items.length * this.size + "px";
```

2. **滚动的时候**：根据滚动的距离更新应该显示的数据，即显示元素的起始位置。同时计算偏移量。

- **显示的列表开始**：滚动的距离/每一项的高度，向下取整  
- **显示的列表结尾**：显示的列表开始+希望展示几条数据
- **偏移量**：根据滚动出可视区域的列表项的个数*每一项列表项的高度，进行反向移动

```js
let scrollTop = this.$refs.viewport.scrollTop;
this.start = Math.floor(scrollTop / this.size);
this.end = this.start + this.remain;
this.offset = this.start * this.size;

:style="{ transform: `translate3d(0,${offset}px,0)` }"
```

3. **问题**：如果刚好渲染的第一项只显示了部分，那么可视区域的最底下就会出现相应高度的空白问题

    **解决方案：**在原先的渲染项数上，再多向前和向后渲染若干项

##### 6.2 `item`高度不固定

1. **多传给组件一个参数`variable`**

2. **利用二分法重新计算`start`**

   1. 在页面渲染完毕之后，对数据数组里每一项的`height`，`top`，`bottom`的值做一个缓存，此时的每一项的`size`值是我们预估的，滚动条的高度并不准确。存放在数组`positions`

   2. 用二分法开始查找，我们页面滚动的`scrollTop`对应`positions`里的哪一项的`bottom`。之所以用二分法查找是因为后面会根据真实的DOM重新计算每一项的`height`，`top`，和`bottom`，到时候每一项的高度就不确定了

   3. 对于`end`，`offset`的计算原理和`item`高度固定的情况一样

3. **页面更新之后**

   页面渲染完成之后，需要根据当前展示的数据，更正缓存的`positions`里面的数据，实现跟新滚动条的高度，这部分的代码用到了`ref`和`getBoundingClientRect`的知识

   1. `ref`，写在v-for的元素上，引用信息包含DOM节点或者组件实例的数据

   2. `getBoundingClientRect()`方法返回元素的大小及相对于视口的位置，除了`width`和`height`以外的属性都是相对于视口的左上角计算的

   > **具体的更新方法：**
   >
   > 获取真实的节点，对于每一个节点，获取其真实的高度
   >
   > 再根据缓存的数据里面找到当前节点的高度
   >
   > 计算高度差，更新当前节点的的`bottom`和`height`
   >
   > 随后再更新后续的节点的`top`值和`bottom`

   3. 更新滚动条的高度，滚动条的高度等于列表最后一项的高度

-----

🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌

👻👻🐷🐷🐷🐽🐽🐽🐖🐖🐖🐬🐬🦩🐣🐤🐥👿😈😶‍🌫️😶‍🌫️❤️❤️❤️🐖🐖🐖😶‍🌫️😶‍🌫️😶‍🌫️🐬🐬👻👻🐷🐽

🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌

-----

## 单多文件上传，大文件切片上传





-----

[1](https://juejin.cn/post/6844904046436843527#heading-26)

[2](https://www.ruanyifeng.com/blog/2018/07/web-worker.html)

利用 Blob.prototype.slice 将文件进行切片，预先定义好单个切片大小，将文件进行切片，传输到服务端的顺序可能会发生变化，因此我们还需要给每个切片记录顺序



文件秒传需要依赖上一步生成的 hash，即在`上传前`，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可

-----

#### 一、需求

1. 校验文件格式

2. 可以上传任何文件，包括超大的视频文件（切片）

3. 上传期间断网，再次联网可以继续上传（断点续传）

4. 有进度条显示

5. 已经上传过同一个文件后，可以直接上传完成（秒传）

#### 二、前端思路

1. ##### 文件切片

   大文件的二进制对象（`file`，`blob`），有一个`slice`方法，通过调用该方法，给一个起点和终点，就可以把大文件切成一个片，一个片的。

2. ##### 文件的唯一值

   如何告诉后端，上传的两个文件是否是同一个文件，需要用到`md5`对文件加密获取唯一的`hash`值。

   生成hash值的方法我们是调用 `spark-md5` 这个库，在计算`hash`的时候是非常消耗计算机的`CPU`的会造成浏览器的卡顿，为了优化体验我们使用 `web-worker` 在 `worker` 线程计算 `hash`，不熟悉的同学请[补补课](https://link.juejin.cn/?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2018%2F07%2Fweb-worker.html)。

   > Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。
   >



#### 二、前后端分工

- 前端：
  1. 文件格式校验
  2. 文件切片，md5计算
  3. 发起检查请求，把当前文件的hash发送给服务端，检查是否有相同的hash的文件
  4. 上传进度条计算
  5. 上传完成后通知后端合并切片

- 后端：

  1. 检查接收到的hash是否有相同的文件，并通知当前hash是否有未完成的上传

  2. 接收切片

  3. 合并切片

- 架构：

  ![](E:\Front\八股文\My八股文\八股图\图片切片上传.png)

#### 三、具体实现

##### 切片上传

​			点击上传按钮，利用`while`和`slice`将文件进行切片，在生成切片的时候，给每个切片生成一个`hash`值，方便后端知道当前切片是第几个切片，用于之后的合并切片

​		随后进行上传切片，将文件切片，切片的`hash`，切片的名字放入到`formData`中，再将`formData`上传到中，最后调用`promise.all`并发上传所有的切片

> ##### 限制请求个数
>
> 我们可以把异步请求放在一个队列`pool`里，比如并发数`max`是4，就先同时发起4个请求，然后有请求结束了，再发起下一个请求即可

##### 断点续传

> ​		断点续传的原理在于前端/服务端需要`记住`已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能
>
> - 前端使用 localStorage 记录已上传的切片 hash
> - 服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片
>
> 第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选后者

##### 生成hash

​		用到一个库 [`spark-md5`](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fspark-md5)，它可以根据文件内容计算出文件的 `hash` 值

​		另外考虑到如果上传一个超大文件，读取文件内容计算 `hash` 是非常耗费时间的，并且会`引起 UI 的阻塞`，导致页面假死状态，所以我们使用 `web-worker` 在 `worker` 线程计算 `hash`，这样用户仍可以在主界面正常的交互

​		由于实例化 `web-worker` 时，参数是一个 `js` 文件路径且不能跨域，所以我们单独创建一个 `hash.js` 文件放在 `public` 目录下，另外在 `worker` 中也是不允许访问 `dom` 的，但它提供了`importScripts` 函数用于导入外部脚本，通过它导入 `spark-md5`

​		在 `worker` 线程中，接受文件切片 `fileChunkList`，利用 `fileReader` 读取每个切片的 `ArrayBuffer` 并不断传入 `spark-md5` 中，每计算完一个切片通过 `postMessage` 向主线程发送一个进度事件，全部完成后将最终的 `hash` 发送给主线程

主线程使用 `postMessage` 给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 postMessage 事件拿到文件 hash

##### 文件秒传

文件秒传，即在服务端已经存在了上传的资源，所以当用户`再次上传`时会直接提示上传成功

文件秒传需要依赖上一步生成的 `hash`，即在`上传前`，先计算出文件 `hash`，并把 `hash` 发送给服务端进行验证，由于 `hash` 的唯一性，所以一旦服务端能找到 `hash` 相同的文件，则直接返回上传成功的信息即可

-----

## 基于Vue+Canvas实现图片的裁切

#### **一、问题：**

项目中经常出现头像的裁剪与上传，对其处理一开始是想找插件，但有些时候插件的功能并不完全能够达到自己的需求，此时，若对其进行更改，则会发现一大堆代码，所有我想自己用原生的`Vue`和`Canvas`实现该功能

-----

#### 二、大致的步骤

做项目之前要先理清步骤

1. **准备数据：**画布的大小，Mark遮罩层的大小，位置，上传图片的大小位置，是否显示遮罩层Mark
2. **点击图片上传：**将其绘制到画布中
3. **实现图片的放大和缩小：**重新绘制图片的大小
4. **实现图片的拖拽：**每次拖拽完要重新绘制新的位置
5. **保存图片：**把遮罩层选中的部分生成新的图片

-----

#### 三、具体的步骤


1. **组件准备：**

2. **准备数据：**画布的大小，Mark遮罩层的大小，位置，上传图片的大小，是否显示遮罩层Mark

3. **点击图片上传：**将其绘制到画布中

  - 用`input`表单元素进行上传

  - **控制文件的上传类型**，接收所有`image`后缀的文件，`accept="image/*"`，`multiple="true"` 批量上传

  - 点击**选中图片按钮 **	==>	 触发`input`中的`change`事件  ==> 将`Mark`显示 ==> 获取上传文件的表单元素（集合）===> 若`file`为空，则 `return` ==> *上传的文件绘制到 `canvas`里面*

     实例化一个`FileReader`对象 ===> 调用`readAsDataURL(file)`将图片转为`base64`编码 ====>

     在文件读取完成后触发`onload` 事件 ===> 创建新的图片，把`base64`编码给它 ===> 当图片加载完成后,获取图片的大小，位置等信息  ===>  重新按照比例计算宽高（横，纵）

     ![](E:\Front\八股文\My八股文\八股图\file.png)

  - **绘制图片**

     > 1. 通过`getContext`创建2D渲染的画布
     > 2. `clearRect`清除画布里面的内容，防止里面有东西
     > 3. 使用 `drawImage` 方法将图像绘制到画布上

4. **实现图片的放大和缩小：**重新绘制图片的大小

​			点击放大和缩小按钮 ===> 计算宽高的比例 ===> 按照比例对图片的宽高进行调整 ===>重新绘制

5. **实现图片的拖拽：**每次拖拽完要重新绘制新的位置

​			先获取鼠标**按下时的坐标**  ===> 当鼠标**移动**的时候，用最新的坐标—起始的坐标算出**差距**  ===> 可以适当设置像素的**偏移误差** ===>  根据偏移的位置**重新计算图片的位置** ==>**重新将图像绘制到画布上** ===> 把最后的坐标当做下一次最开始的值

6. **保存图片：**把遮罩层选中的部分生成新的图片

​					用`getImageData`的方法获取到指定区域的图像数据 ===> 创建第二张画布，用于生成图片 ===>

​					设置第二张画布的宽度和高度 ===>  `putImageData` 将像素信息放入第二张画布 ===>

​					通过`toDataURL`将画布内容生成最终的图片的 `base64` 格式===> 触发自定义事件，将生成的图片 `base64` 数据传递给父组件 ===>父组件拿到图片`base64`，对其进行展示

7. `FormData` 对象来创建一个表单数据，并通过 `append` 方法将名为 `"image"` 的文件数据（即 `blob` 对象）添加到表单中。

#### 四、注意事项

1. 开发组件的时候，通过传递不同的属性来控制的，指定画布大小，指定mark大小，控制图片能移动，还是mark能移动，控制图片能放大缩小还是mark能放大缩小

2. `CDN`代表内容分发网络
3. `canvas`在输出图片时会因画布污染导致跨域，需要设置`crossOrigin`为 `Anonymous`以及`setRequestHeader`等
4. 本文主要介绍了一个完整的裁剪过程的大致实现，至于一些比较定制的功能（**批量裁剪、缩放裁剪、定向尺寸裁剪**等），原理其实都大同小异，只是如何操作批量的图片信息、裁剪信息的问题罢了
5. 操作`canvas`最重要的一点就是关于坐标的计算，尤其是旋转的坐标，一定要细心地理清楚。其实整个流程下来，只要思路清晰，还是挺简单的。

-----

🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌

👻👻🐷🐷🐷🐽🐽🐽🐖🐖🐖🐬🐬🦩🐣🐤🐥👿😈😶‍🌫️😶‍🌫️❤️❤️❤️🐖🐖🐖😶‍🌫️😶‍🌫️😶‍🌫️🐬🐬👻👻🐷🐽

🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌🙌

## 图片压缩

#### 一、问题：

有些需求需要用户上传照片，而上传图片可能太大，导致上传时间过长，用户体验下降，这时候可以考虑前端做好图片文件压缩，减轻服务器压力。

#### 二、实现逻辑：

![图片压缩](E:\Front\八股文\My八股文\八股图\图片压缩.png)

#### 三、重点

#### 1. file文件转base64

![](E:\Front\八股文\My八股文\八股图\file文件转base64格式.png)



#### 2.通过Canvas对Base64数据进行压缩

![](E:\Front\八股文\My八股文\八股图\通过Canvas对Base64数据进行压缩.png)

#### 3.Base64格式转Blob二进制格式

![](E:\Front\八股文\My八股文\八股图\Base64格式转Blob二进制格式.png)

#### 四、流程

1. **获取file文件：**

   当文件选择框的值发生改变时，触发`onchange`事件，并获取选择的文件对象。

2. **file文件转base64格式：**

   创建`FileReader`对象，通过`FileReader.readAsDataURL`将文件转化为`base64`格式，会触发`FileReader.onload`事件，进行下一步压缩

3. **通过canvas对base64 数据进行压缩：**

   通过`getContext`获取了`<canvas>`元素的2D渲染上下文，然后通过`drawImage`将图像绘制到画布上，最后通过 `toDataURL`将图片进行压缩，

4. **将base64数据转化为Blob二进制格式：**

   `window.atob`进行解码`Base64` 格式数据，通过`ArrayBuffer`创建定制长度的Buffer（二进制）文件，通过`Uint8Array`更改初始的二进制文件，将处理后的数据塞入一个新的`Blob`对象中，利用`createObjectURL`转化为`DataUrl`格式

5. **构建FormData数据，进行append文件上传：**

​    `img.crossOrigin = "anonymous";`

-----



## 其他项目亮点

#### 1.防止重复的提交

一般使用的是防抖和节流，节流函数通过控制每次时间执行的时间间隔，控制短时间多次执行方法。防抖函数是推迟每次事件执行的时间减少不必要的查询。但是网络慢的时候，还是会重复提交，没有显示状态，用户不知道有没有真的提交。

所以就给按钮添加一个加载状态，查了发现el-button自带了loading属性，传参的时候传一个submit函数，是一个Promise,promise状态改变的时候把loading状态改成false。然后点击按钮会有加载动画，加载的时候，按钮是禁用的。

#### 2.解析数据

填写信息的页面，返回的时候填写信息需要缓存，要用vue的keep-alive实现

#### 3.路由懒加载

需要的时候进行加载，把不同路由对应的组件分成不同代码块，路由被访问才加载对应组件。路由会定义很多页面，页面打包后放到单独的`js`文件会导致非常大，懒加载把页面进行划分，需要时才加载，减少首页加载速度，懒加载主要就是把对应组件打包成`js`代码块进入首屏不用加载过度的资源，从而减少首屏加载速度。就是用`import`，在路由配置的`router.js`，`import`设置好的组件，`from`后面写的是组件的路径

#### 4.Proxy实现跨域（vue项目)

在`vue.config.js`里面设置好`proxy`,里面写`'/api'{}`作为拦截，里面写好`target:后端的接口网址`，`changeOrigin:true，pathRewrite:{}`

#### 5.scoped时修改子组件样式

`vue`文件正常样式写在`</script>`中，会被自动加上一个`[data-v-xxxx]`属性，但是第三方组件内部标签没有编译为这个属性，所以不能修改这个第三方组件。 为了父组件不影响子组件，用`scoped`,

有一个方法是给第三方组件写`class`,然后在公共`css`或者当前页面写一个没有`scoped`的`style`,直接在里面修改第三方组件的样式，但是存在全局污染和命名冲突，约定的那个特殊的命名方式可以避免命名冲突。

查找资料发现可以用深度选择器解决。深度选择器用`/deep/`，用到`ElemntUI`,又有预处理器就可以用`.::v-deep`。`vue`中过多使用`scoped`导致页面打包文件体积增大。通常能写在`index`中的样式尽量写在`index`中，我们可以通过在`index`样式中通过外层组件添加唯一`class`来区分组件+`第三方样式`来实现了类似于`scoped`的效果，又方便修改各种第三方组件的样式

-----

## 基于JS实现Ajax并发请求控制



