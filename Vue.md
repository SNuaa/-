# Vue

### 1. 基础知识

#### 1.1 指令

在 Vue 中，指令（Directives）是一种特殊的属性，用于提供对 **DOM 元素的直接操作和控制**。

##### **Ⅰ.  内置指令：**

1. **v-bind：**用于动态绑定数据到**元素的属性**。可以简写为 `:`。

   例如，`v-bind:href="url"` 会将 `url` 数据绑定到元素的 `href` 属性上。

2. **v-model：**用于在**表单元素**上实现**双向数据**绑定。可以将表单元素的值与 Vue 实例的数据进行关联。

   例如，`v-model="message"` 会将输入框的值与 Vue 实例的 `message` 数据进行双向绑定。

3. **v-for：**用于渲染列表数据，根据**数组或对象**的内容进行循环渲染。

   可以使用 `v-for="(item, index) in items"` 的语法来遍历数据。例如，`v-for="item in items"` 可以用于渲染一个数组中的每个元素。

4. **v-if / v-else-if / v-else：**用于条件渲染，根据表达式的值来判断是否渲染元素。

   例如，`v-if="isShow"` 可以根据 `isShow` 数据的值决定是否渲染元素，同时也可以使用 `v-else-if` 和 `v-else` 进行多条件判断。

5. **v-show：**与 `v-if` 类似，用于条件渲染元素，但是使用 CSS 的 `display` 属性来控制元素的显示与隐藏。与 `v-if` 不同的是，`v-show` 只是切换元素的显示与隐藏状态，而不会重新渲染元素。

6. **v-on：**用于**绑定事件监听器**，响应 DOM 事件，并执行对应的方法。可以简写为 `@`。

   例如，`v-on:click="handleClick"` 或 `@click="handleClick"` 可以在元素被点击时执行 `handleClick` 方法。

7. **v-text：**向其所在的节点中渲染**文本内容**（双向）。

   > `v-text` 会替换掉节点中的内容，`{{ }}`不会，更灵活。类似于插值表达式 `{{ }}`，但是 `v-text` 是指令，可以在元素初始化时避免出现闪烁。                 
   >
   > **原因：**
   >
   > （1）当页面渲染时，Vue 会先进行**模板编译，将模板转换为虚拟 DOM（JS模拟的DOM结构），并建立起与数据的关联关系**。在初始化过程中，如果使用了插值表达式 `{{ }}`，当 Vue 还未完成**数据的响应式更新时**，插值表达式会显示为**占位符**，直到数据更新后才会被替换为真正的值。这个过程会导致页面在一开始出现插值表达式的占位符，然后再被真正的值替换，从而产生闪烁的效果。
   >
   > （2）而 `v-text` 指令的工作机制是**直接将数据绑定到元素的文本内容上**，而不是通过插值表达式进行替换。当 Vue 进行初始化时，`v-text` 指令会**立即将绑定的数据**显示在元素上，避免了出现插值表达式的占位符。这样，在页面渲染时就不会出现闪烁的情况。
   >

8. **v-html :** 向其所在的节点中渲染**包含html结构的内容**（双向绑定）。

   > **与其他的区别：**
   >
   > （1）`v-html`会替换节点的所有内容，`v-text` 指令直接替换元素的文本内容，`{{XXX}}`不会；
   >
   > （2）`v-html`可以识别html结构
   >
   > **存在安全问题：**
   >
   > ​	易受XSS攻击，要确保渲染的内容是可信的
   >
   > ​	XSS（Cross-Site Scripting）攻击是一种常见的网络安全漏洞。XSS 攻击的原理是攻击者通过在受信任网站上注入恶意脚本，这些脚本可以由用户浏览器执行。恶意脚本可以窃取用户的敏感信息，如登录凭据、Cookie 数据，甚至可以修改网页内容或重定向用户到恶意网站。

9. **ref：**为某个元素注册一个唯一标识, vue对象通过`$refs`属性访问这个元素对象

10. **v-cloak：**配合css使用，用于解决在初始渲染过程中出现**闪烁**的问题

    > ```html
    > <div v-clock>{{ data }}</div>
    > 
    > [v-clock] {
    > 	display: none;
    > }
    > ```
    >
    > 比如网速慢，在 vue 初始化之前，由于 div 是不归 vue 管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，页面展示出`{{XXX}}`。在Vue示例创建完毕并接管容器之后，会删掉该属性。`v-cloak` 的作用是在 Vue 实例渲染完成之前，**将元素隐藏起来**，直到 Vue 实例完成编译和渲染，然后再移除隐藏样式，确保元素显示出预期的效果。

11. **v-once：**所在的节点初次渲染后，就视为静态内容了，以后的数据改变不会引起该节点所在的结构更新，可用于数据优化
12. **v-pre： **跳过所在节点的编译过程,用它跳过没有使用指令语法,插值语法的节点,**加快编译**

##### **Ⅱ. 自定义指令：**

全局注册/局部注册

(1) **全局注册：**`Vue.directive(指令名,配置对象/回调函数)`

(2) **局部注册:** 通过在组件`options`选项中设置`directive`属性

```js
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
    }
  }
}
```

> **自定义指令也像组件那样存在钩子函数：**(配合语雀+面试官食用)
>
> - `bind`：只调用一次，指令**第一次**绑定到元素时调用。在这里可以进行一次性的初始化设置
> - `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)
> - `update`：所在组件的 `VNode` 更新时调用，但是可能发生在其子 `VNode` 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新.**指令所在的模板被解析时.**
> - `componentUpdated`：指令所在组件的 `VNode` 及其子 `VNode` 全部更新后调用
> - `unbind`：只调用一次，指令与元素解绑时调用
>
> **所有的钩子函数的参数都有以下：**
>
> - `el`：指令所绑定的元素，可以用来直接操作 `DOM`
> - `binding`:要绑定的对象，包含以下`property`:
>   - `name`：指令名，不包括 `v-` 前缀。
>   - `value`：指令的绑定值，例如：`v-my-directive="1 + 1"` 中，绑定值为 `2`。
>   - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。
>   - `expression`：字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`。
>   - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `"foo"`。
>   - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`
> - `vnode`：`Vue` 编译生成的虚拟节点
> - `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用
>
> > 除了 `el` 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 `dataset` 来进行.指令定义的时候不加v-,使用的时候加v-.

##### **Ⅲ. 应用场景:**

- 表单防止重复提交

- 图片懒加载 

  图片懒加载其实就是**延迟加载**。也就是不用一次性加载所有的图片，等到用户需要某张图片的时候再加载，这样可以避免在同一时间请求大量的数据。也就是当图片滚动到可视区域的时候再去加载图片。

- 一键 Copy的功能

(----------------------------------------------------------代码的实现待完善!!!!后续再看---------------------------------------------------------)

> 如何写一个自定义指令，为什么要用自定义指令而不是其他的方案？
>
> 1. 提供可复用的行为：自定义指令可以在多个组件中共享和复用，使得相同的功能可以在不同的组件中实现，提高了代码的可维护性和复用性。
> 2. 直接操作 DOM：自定义指令允许直接操作元素的 DOM，可以完成一些与 UI 相关的交互和操作，例如修改元素样式、绑定事件等，比如实现自定义的验证逻辑、拖拽功能等。
> 3. 解耦视图和逻辑：通过自定义指令，你可以将一些和视图相关的逻辑抽离到指令中，让组件更专注于数据和业务逻辑，提高代码的可读性和可维护性。

------

#### 1.2 v-if 与 v-show 

**相同点:**

`v-if` 与 `v-show` 都能控制`dom`元素在页面是否显示

**不同点:**

1. v-if是控制元素是否加载到页面上（有性能开销）

2. v-show是控制元素的显示与隐藏 （初始创建时加载一次）

> 1.**控制手段**：`v-show`隐藏则是为该元素添加`css--display:none`，`dom`元素依旧还在。`v-if`显示隐藏是将`dom`元素整个添加或删除
>
> 2.**编译过程**：`v-if`切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；`v-show`只是简单的基于css切换
>
> 3.**编译条件**：`v-if`是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染
>
> - `v-show` 由`false`变为`true`的时候不会触发组件的生命周期
> - `v-if`由`false`变为`true`的时候，触发组件的`beforeCreate`、`create`、`beforeMount`、`mounted`钩子，由`true`变为`false`的时候触发组件的`beforeDestory`、`destoryed`方法
>
> 4.性能消耗：`v-if`有更高的切换消耗；`v-show`有更高的初始渲染消耗；

**使用场景:**

1. 如果需要非常频繁地切换，则使用 v-show 较好

2. 如果在运行时条件很少改变，则使用 v-if 较好

(-----------------------------------------v-show与v-if原理分析没看!!!!后续再看---------------------------------------------------------)

------

#### 1.4 v-for与v-if

**Ⅰ. 作用**

`v-if` 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 `true`值的时候被渲染

`v-for` 指令基于一个数组来渲染一个列表。`v-for` 指令需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据数组或者对象，而 `item` 则是被迭代的数组元素的别名

在 `v-for` 的时候，建议设置`key`值，并且保证每个`key`值是独一无二的，这便于**`diff`算法进行优化**

```js
<Modal v-if="isShow" />

<li v-for="item in items" :key="item.id">
    {{ item.label }}
</li>
```

**Ⅱ. 优先级**

**`v-for`优先级比`v-if`高**

> 1. 永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）
> 2. 如果避免出现这种情况，则在外层嵌套`template`（页面渲染不生成`dom`节点），在这一层进行v-if判断，然后在内部进行v-for循环
> 3. 如果条件出现在循环内部，可通过计算属性`computed`提前过滤掉那些不需要显示的项

------

#### 1.5  data computed methods watch

##### Ⅰ. 概念

`data`:存储组件的状态和数据

`computed`:根据已有的数据属性计算衍生的属性

> **原理:**底层借用了Objcet.defineproperty()方法提供的getter和setter方法 
>
> **getter什么时候被调用?** (1)初次读取数据的时候 (2)依赖的数据发生变化的时候
>
> **优势:**与method相比内部有缓存机制(复用),效率高,调试方便 

`methods`:定义组件的方法和待执行的函数

> 在只读的模式下可以简写,但是如果计算属性的值要被修改,必须写set()函数去响应修改,且set中要引起计算时依赖的数据发生改变

`watch`:

> 侦听器可以监听**data对象属性**或者**计算属性**的变化, 当监听的属性发生变化时，侦听器会被传入两个参数：所监听属性的**当前值**和原来的旧值
>
> immediate:true 立即监听
>
> deep:true 深度监听
>
> handler(newValue,oldValue) 当数据改变时，调用

|          | 可读 | 可写 | 接受参数 | 需要运算 | 有缓存 |
| :------: | :--: | :--: | :------: | :------: | :----: |
|   data   |  是  |  是  |    否    |    否    |   /    |
| computed |  是  |  是  |    否    |    是    |   是   |
| methods  |  是  |  否  |    是    |    是    |   否   |

##### Ⅱ. data属性

1. 为什么组件中的data属性是一个函数而不是一个对象？

> - 根实例对象`data`可以是对象也可以是函数（根实例是单例），不会产生数据污染情况
>
> - 组件实例对象`data`必须为函数，目的是为了防止多个组件实例对象之间共用一个`data`，产生数据污染。采用函数的形式，`initData`时会将其作为工厂函数都会返回全新`data`对象
>
>   "一个组件可以在同一个页面上被多次引用，不希望它们共享一个data对象
>   因为同一个组件的每个实例的data属性是同一个对象的引用，当该组件的某个实例修改了自身的data属性，相当于所有实例的data属性都被修改了
>   所以组件的data属性应该是一个函数，在组件初始化时Vue会调用这个函数来生成data对象"

2. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗?

> (1) 不会立刻渲染
>
> Vue采用**异步的**方式来更新视图,提高性能和效率
>
> 当你修改 `data` 中的某个属性时，Vue 会将该修改标记为"脏"，并在下一个事件循环中进行视图的更新。这意味着，**如果在同一个事件循环中多次修改同一个属性(循环操作)，Vue 只会进行一次视图更新**，而不会对每次修改都重新渲染视图。
>
> 这种异步更新的机制称为 "批量异步更新" 或 "异步队列"。Vue 将多个数据变化收集起来，在适当的时机进行一次性的更新操作，以减少不必要的重复渲染。这样可以提高性能，避免频繁的视图更新。
>
> (2) 若需要在数据变化后立即执行某些操作?
>
> `watch` 属性: 来监听数据的变化并**执行相应的操作**
>
> `computed`属性: 在计算属性中定义一个 getter 函数，并在函数中执行你需要的操作
>
> `$nextTick` 方法: 允许你在下一次 DOM 更新周期之后执行回调函数，确保在视图更新后再执行你的操作

> 在Vue中，事件循环指的是处理异步任务的机制。它是一种用于管理和调度异步任务的执行顺序的机制。
>
> Vue使用事件循环来处理异步任务，以确保数据的变更和DOM的更新是在适当的时机进行的，以避免不一致或不可预测的结果。Vue的事件循环机制保证了以下几点：
>
> 1. 异步任务的执行顺序：Vue将异步任务划分为不同的阶段，比如"渲染阶段"和"更新阶段"，并按照特定的顺序执行这些任务，以确保正确的更新顺序和避免不必要的重绘。
> 2. 批量更新：Vue在事件循环过程中收集数据变更，并在下一个"更新阶段"统一处理这些变更。这样可以避免频繁的更新操作，提高性能并减少不必要的重绘。
> 3. 异步更新：Vue的数据变更和DOM更新是异步执行的，即使在同一个事件循环中，Vue也会将更新推迟到下一个事件循环中执行，以确保更新操作不会阻塞主线程，保持页面的流畅性

3. computed和watch的区别

> - `computed` 适用于基于已有的响应式数据计算得出新的值，且计算结果会被缓存，只有在依赖的数据变化时才重新计算。
> - `watch` 用于监听指定的数据的变化，并在变化发生时执行特定的操作，适用于需要对数据变化进行响应式处理的场景
> - 如果你需要基于**已有数据进行计算，并且需要缓存计算结果**，那么使用 `computed` 是更合适的选择。
> - 如果你需要在**数据变化时执行异步操作、执行耗时计算或触发其他方法**，那么使用 `watch` 更适合。

#### 1.6 方法中的this

- 在方法中，this指向该方法所属的组件

- 可以使用this访问data对象的属性和其他方法

> ```js
> // 定义一个对象
> const obj = {
>   name: 'John',
>   sayHello: function() {
>     setTimeout(function() {
>       // 在回调函数中使用 this，指向的是全局对象（浏览器中是 window）
>       console.log('Hello, ' + this.name);
>     }, 1000);
>   }
> };
> 
> obj.sayHello();
> ```
>
> ```js
> const obj = {
>   name: 'John',
>   sayHello: function() {
>     setTimeout(() => {
>       // 使用箭头函数，this 仍然指向 obj 对象
>       console.log('Hello, ' + this.name);
>     }, 1000);
>   }
> };
> 
> obj.sayHello();
> ```
>
> 

------

#### 1.7 事件对象（Event Object）

在事件触发时由浏览器自动创建的对象，它包含了与该事件**相关的信息和属性**。

当事件被触发时（例如点击按钮、鼠标移动、键盘按下等），浏览器会自动创建一个事件对象，并将该对象传递给事件处理函数。事件对象提供了**对事件的详细信息和属性的访问**，让开发者能够对事件进行处理和作出相应的反应。

事件对象常用的属性和方法包括：

- `event.target`：事件的目标元素，即触发该事件的元素。
- `event.currentTarget`：当前正在处理事件的元素，可能与目标元素不同。
- `event.type`：事件的类型，例如 "click"、"mouseover"、"keydown" 等。
- `event.preventDefault()`：阻止事件的默认行为，例如阻止表单提交或超链接跳转。
- `event.stopPropagation()`：阻止事件的冒泡，即停止事件向父元素传播。
- `event.keyCode`：按下的键盘按键的键码值。
- `event.clientX` 和 `event.clientY`：鼠标事件发生时的鼠标坐标。
- `event.once` 只在第一次触发事件的时候触发事件侦听器
- `event.capture` 使用捕获模式
- `event.self` 只监听元素自身而不是它的子元素上触发的事件
- 其他根据事件类型而定的属性和方法。

通过事件对象，你可以获取触发事件的元素、事件类型、相关坐标等信息，并可以在事件处理函数中使用这些信息来执行特定的操作。事件对象使得开发者能够对用户的交互作出响应，并对页面元素进行动态的操作和交互。

> 默认传入 `$event`
> 有参数时，显式的在最后传入 `$event`
>
> ```js
> <p>{{number}}</p>
> <button @click="incrementBy1">点击+1</button>
> <button @click="incrementBy10(10, $event)">点击+10</button>
> ...
> data(){
> 	return {
> 		number: 0
> 	}
> }
> methods: {
> 	incrementBy1(e){
> 		this.number++
> 		console.log(e.__proto__.constructor) // f MouseEvent()
> 		console.log(e.target) // <button>点击+1</button>
> 		console.log(e.currentTarget) // <button>点击+1</button>
> 	},
> 	incrementBy10(step, e){
> 		this.number+=step
> 		console.log(e.__proto__.constructor) // f MouseEvent()
> 	}
> }
> ```
>
> 

------

#### 1.8 动态绑定class、style

------

#### 1.9 过滤器(Vue3弃用)

对要显示的数据进行特定格式化后显示

> **注册:**
>
> `Vue.filter(name,callback)` 全局过滤器
>
> `new Vue(filters:{ })` 局部过滤器
>
> **使用:**
>
> `{{ XXX|过滤器名}}`         `v-bind:属性 = "XXX| 过滤器名"`
>
> **注意:**
>
> 1. 可以接受额外的参数,多个过滤器可以**串联**
>
> 2. **未改变原来的数据**,而是产生新的数据
>
> 3. 过滤器是组件中唯一**不能使用this**来访问数据或者方法的地方. 因为过滤器应该是**纯函数**，也就是说对于同样的输入每次都返回同样的输出，而不涉及任何外部数据。如果想在过滤器中访问其他数据，可以将它作为参数传入
> 4. 局部过滤器优先于全局过滤器被调用
>
> **应用场景:**
>
> ​	单位转换、数字打点、文本格式化、时间格式化之类
>
> **原理分析**:
>
> (-------------------------------------------------------------------未看------------------------------------------------------------------------------)
>
> ```js
> filters: {
>   capitalize: function (value) {
>     if (!value) return ''
>     value = value.toString()
>     return value.charAt(0).toUpperCase() + value.slice(1)
>   }
> }
> ```
>
> ```js
> Vue.filter('capitalize', function (value) {
>   if (!value) return ''
>   value = value.toString()
>   return value.charAt(0).toUpperCase() + value.slice(1)
> })
> 
> new Vue({
>   // ...
> })
> ```
------
#### 1.10 生命周期钩子

**生命周期钩子:**一系列会在组件生命周期——**从组件创建,更新,销毁**——的各个阶段调用的函数. this指向是vm或组件实例对象

**Vue生命周期总共可以分为8个阶段：**创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期

> | 生命周期      | 描述                                                         |
> | :------------ | ------------------------------------------------------------ |
> | beforeCreate  | 组件实例被创建之初                                           |
> | created       | 组件实例完全创建-----被添加到DOM之前触发                     |
> | beforeMount   | 组件挂载之前-----会在元素已经准备好被添加到DOM，但还没有添加的时候触发 |
> | mounted       | 组件挂载到实例上去之后-----会在元素创建后触发（但并不一定已经添加到了DOM，可以用nextTick来保证这一点） |
> | beforeUpdate  | 组件数据发生变化，更新之前                                   |
> | updated       | 组件数据更新之后-----会在DOM的更改已经完成后触发             |
> | beforeDestroy | 组件实例销毁之前-----会在组件即将被销毁并且从DOM上移除时触发 |
> | destroyed     | 组件实例销毁之后                                             |
> | activated     | keep-alive 缓存的组件激活时                                  |
> | deactivated   | keep-alive 缓存的组件停用时调用                              |
> | errorCaptured | 捕获一个来自子孙组件的错误时被调用                           |
>
> ![生命周期](E:\Front\八股文\My八股文\八股图\生命周期.png)

> **数据请求在created和mouted的区别**?
>
> > `created`是在**组件实例一旦创建完成的时候**立刻调用，这时候页面`dom`节点并未生成；
>>
> > `mounted`是在**页面`dom`节点渲染完毕**之后就立刻执行的。
>>
> > 触发时机上`created`是比`mounted`要更早的，两者的相同点：**都能拿到实例对象的属性和方法**。 
>>
> > 讨论这个问题本质就是触发的时机，放在`mounted`中的请求有可能导致页面闪动（因为此时页面`dom`结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在`created`生命周期当中

> **一般在哪个生命周期请求异步数据**
>
> > 我们可以在钩子函数 `created、beforeMount、mounted` 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。
> >
> > 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下**优点**：
> >
> > 1. 能更快获取到服务端数据，减少页面加载时间，用户体验更好；
> > 2. SSR (服务端渲染)不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性

> Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 
> 每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。 
> 实例、组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行beforeCreate钩子函数，这个时候，数据还没有挂载呢，只是一个空壳，无法访问到数据和真实的dom，一般不做操作 
> 挂载数据，绑定事件等等，然后执行created函数，这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数，在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 
> 接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染，然后执行beforeMount钩子函数，在这个函数中虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated，在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取 
> 接下来开始render，渲染出真实dom，然后执行mounted钩子函数，此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了，可以在这里操作真实dom等事情... 
> 当组件或实例的数据更改之后，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染，一般不做什么事儿 
> 当更新完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom 
> 当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、清除非指令绑定的事件等等 
> 组件的数据绑定、监听...去掉后只剩下dom空壳，这个时候，执行destroyed，在这里做善后工作也可以 

------
#### 1.11 NextTick

> **得分点** 
>
> ​		异步渲染、获取DOM、Promise
>
> **是什么?**
>
> Vue 是异步渲染, data改变后，DOM不会立即渲染
> $nextTick 会在DOM渲染之后被触发，以获取最新的DOM节点
>
> <!--在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的 DOM 结构的时候，这个操作就需要方法在 nextTick()的回调函数中。在 vue 生命周期中，如果在created()钩子进行DOM 操作，也一定要放在nextTick()的回调函数中。因为在created()钩子函数中，页面的DOM 还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。-->
>
> **使用方法:**
>
> `Vue.nextTick( [callback, context] )`
>
> `vm.$nextTick( [callback, context] )`
>
> **使用场景:**
>
> 如果想要在修改数据后立刻得到更新后的`DOM`结构，可以使用`Vue.nextTick()`
>
> ```vue
> Vue.nextTick(function () {
> // 在 DOM 更新后执行的代码
> // 可以安全地访问更新后的 DOM
> });
> ```

------

#### 1.12 自定义实现v-model

v-model实现数据双向绑定实际上是一个语法糖,实际上是对组件的 `value` 属性和 `input` 事件进行了封装

```html
<input type="text" v-model="name">
```

```html
<input type="text" :value="name" @input="name = $event.target.value">
```

> 一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用来避免这样的冲突：

-----

#### 1.14 MVVM模型

**定义:数据驱动视图**

> **Model:**数据模型，模型代表应用程序的**数据**和**业务逻辑**
>
> **View :**代表UI 视图，负责数据的展示, 模板代码；
>
> **ViewModel:**负责监听Model 中**数据的改变**并且**控制视图的更新**，处理**用户交互操作**；
>
> Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发View 层的刷新，View 中由于**用户交互操作而改变**的数据也会在Model 中同步。
>
> 这种模式实现了 Model 和View 的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。
>
> ![MVVM](E:\Front\八股文\My八股文\八股图\MVVM.png)

**MVVM 的优缺点?**

> **优点:**
>
> 1. **分离关注点**：MVVM模式将数据逻辑和视图逻辑分离，使代码更具可读性、可维护性和可测试性。模型负责处理数据和业务逻辑，视图负责展示数据，而视图模型负责连接模型和视图，处理数据绑定和交互逻辑。
>
> 2. **双向数据绑定：**MVVM模式通过数据绑定实现了模型和视图之间的双向同步。当模型中的数据发生变化时，视图会自动更新；反之，当用户在视图中进行操作时，模型中的数据也会随之更新。这减少了手动操作DOM的工作量，提高了开发效率。
>
> 3. **可复用性：**MVVM模式鼓励将视图和视图模型分离，使得视图可以被复用于不同的视图模型。这样，开发者可以更容易地创建可复用的组件，并将它们组合成不同的页面。
>
> 4. **开发效率**：由于MVVM模式中的数据绑定和自动更新机制，开发者可以更专注于业务逻辑的实现，而不用过多关注视图的更新和同步问题。这提高了开发效率，并减少了开发中的出错机会。
>
> **缺点:**
>
> 1. **难调试:**因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得⼀个位置的Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写.在 View 的模版当中的，这些内容是**没办法去打断点debug** 的.
> 2. **性能问题**:**频繁的数据绑定和自动更新**可能会导致性能下降，特别是在处理大规模数据或复杂视图时。
> 3. **复杂性：**MVVM模式引入了视图模型层，增加了整体架构的复杂性。需要合理地设计和组织视图模型，确保它们能够正确地与模型和视图进行**通信**，以避免过度耦合和维护困难。

-----

### 2. 组件相关

#### 2.1 data为什么是函数?

见1.5

-----

#### 2.2 组件间通信

##### Ⅰ.`props` 传递(父->子)

- 子组件设置`props`属性，定义接收父组件传递过来的参数
- 父组件在使用子组件标签中通过字面量来传递值

```vue
<--------子-------->
props:{  
 // 字符串形式  
 name:String // 接收的类型参数  
 // 对象形式  
 age:{    
     type:Number, // 接收的类型为数值  
     defaule:18,  // 默认值为18  
     require:true // age属性必须传递  
 }  
} 
<--------父-------->
<Children name="jack" age=18 />  
```

##### Ⅱ.`$emit` 触发自定义事件(父->子)

- 子组件通过`$emit触发`自定义事件，`$emit`第二个参数为传递的数值
- 父组件**绑定监听器**获取到子组件传递过来的参数

```Vue
<-------子,携带需要传输的数据------------->
this.$emit('add', this.title)
<-------父,组件监听add事件------------->
<MyInput @add="add">
<------父,组件中定义add方法，获取传入的数据，进行操作------->    
methods: {
	add(title){
		// 得到数据可以进行操作了
		this.list.push({
			id: Math.random(),
			title
		})
	}
}
```

##### Ⅲ. `ref`(子->父)

- 父组件在使用子组件的时候设置`ref`
- 父组件通过设置子组件`ref`来获取子组件的属性和方法

```Vue
<Children ref="foo" />  
</----获取子组件实例，通过子组件实例我们就能拿到对应的数据--->  
</----注意是实例,然后通过实例来获取子组件中的一些方法或者属性,避免滥用>
this.$refs.foo   
```

##### Ⅳ. `EventBus`事件总线 `.$emit` `.$on`(任意间,兄弟组件传值)

- 创建一个中央事件总线`EventBus`
- 一个组件通过`$emit`触发自定义事件，`$emit`第二个参数为传递的数值
- 另一个组件通过`$on`监听自定义事件
- `$on $emit $off` :绑定 触发 解绑

> 1. **定义全局事件总线**
>
>    ​	将当前**Vue实例**作为**事件总线**，将其**挂载到Vue原型**上，从而在整个应用中可以通过**this.$bus**访问到事件总线,在任何组件中使用`this.$bus`来访问事件总线，并使用其提供的事件注册和触发方法.**本质就是一个对象**
>
>    ```vue
>    // main.js
>    new Vue({
>    	...
>    	beforeCreate(){
>    		</-安装全局事件总线,$bus就是当前应用的vm-->
>    		Vue.prototype.$bus=this
>    	},
>    	...
>    })
>    ```
>
> 2. **使用全局事件总线**    
>
>    **a. 接受数据:**A组件想接受数据,则在A组件中给$bus绑定自定义事件,事件的回调留在A组件自身,即:**监听并响应该事件**
>
>    `this.$bus.$on('foo', this.handle) )`
>
>    **b.提供数据:**一个组件中触发自定义事件
>
>    `this.$bus.$emit('foo',data)`  
>
> 3. **解绑事件监听**
>
>    ```vue
>    beforeDestroy(){
>    	this.$bus.$off('foo', this.handle)
>    }
>    ```
>

##### Ⅴ. `$parent` 或`$root`

- 通过共同祖辈`$parent`或者`$root`搭建通信桥连

> **兄弟组件**
>
> `this.$parent.on('add',this.add)`
>
> **另一个兄弟组件**
>
> `this.$parent.emit('add')`

##### Ⅵ. `$attrs` 与`$listeners`(祖先传递数据给子孙)

##### Ⅶ. `provide` 与 `inject`

##### Ⅷ.`vuex`

- 适用场景: 复杂关系的组件数据传递
- `Vuex`作用相当于一个用来存储共享变量的容器

> **Vuex有哪几种属性？**
>
> - `state`用来存放**共享变量**的地方
>
> - `getter`，可以增加一个`getter`派生状态，(相当于`store`中的计算属性），用来获得共享变量的值
>
> - `mutations`用来存放修改`state`的方法。
>
> - `actions`也是用来存放修改`state`的方法，不过`action`是在`mutations`的基础上进行。常用来做一些异步操作
>
>   ![Vuex](E:\Front\八股文\My八股文\八股图\Vuex.png)

##### Ⅸ.小结

- 父子关系的组件数据传递选择 `props` 与 `$emit`进行传递，也可选择`ref`
- 兄弟关系的组件数据传递可选择`$bus`，其次可以选择`$parent`进行传递
- 祖先与后代组件数据传递可选择`attrs`与`listeners`或者 `Provide`与 `Inject`
- 复杂关系的组件数据传递可以通过`vuex`存放共享的变量
-----
#### 2.3 `slot`插槽

**是什么:**Vue内容的分发机制,让**父组件可以向子组件指定的位置插入html结构**,也是一种组件间的**通信方式**(父->子)

**分类:**默认插槽,具名插槽,作用域插槽

**使用场景:**

1. 通过插槽可以让用户可以**拓展组件**，去更好地复用组件和对其做定制化处理
2. 如果父组件在使用到一个复用组件的时候，获取这个组件在**不同的地方有少量的**更改，如果去重写组件是一件不明智的事情
3. 通过`slot`插槽向组件内部指定位置**传递内容**，完成这个**复用**组件在不同场景的应用
4. 比如布局组件、表格列、下拉选、弹框显示内容等

> **使用方式:**
>
> 1. 默认插槽:
>
> 2. 具名插槽: 
>
> 3. 作用域插槽: scope用于父组件往子组件插槽放的html结构接受子组件的数据
>
>    数据在组件自身,但数据生成的结构需要组件的使用者来决定
>
>    <-----------------------------------------见语雀笔记---------------------------------------------->

-----

#### 2.4 动态组件

动态组件允许你**根据不同的条件或事件**动态地切换组件的显示。通过使用动态组件，你可以根据需要在同一个位置渲染不同的组件。使用is特性来选择要挂载的组件

Vue提供了`<component>`元素作为动态组件的容器，你可以将需要动态渲染的组件包裹在`<component>`中，并通过动态绑定`is`属性来指定要渲染的组件。

> **数据:**
>
> ```vue
> data() {
>   return {
>     produceData: [
>       { id: 1, type: 'Video' },
>       { id: 2, type: 'Text' },
>       { id: 3, type: 'Image' },
>       { id: 4, type: 'Text' }
>     ]
>   }
> }
> ```
>
> **引入组件:**
>
> ```vue
> import MyImage from './components/MyImage.vue'
> import MyText from './components/MyText.vue'
> import MyVideo from './components/MyVideo.vue'
> ```
>
> **动态渲染:**
>
> ```VUe
> <div v-for="item in produceData" :key="item.id">
>   <component :is="`My${item.type}`"></component>
> </div>
> ```
>
> **其他演示:**
>
> ```vue
> <template>
>   <div>
>     <button @click="toggleComponent">切换组件</button>
>     <component :is="currentComponent"></component>
>   </div>
> </template>
> 
> <script>
> import ComponentA from './ComponentA.vue';
> import ComponentB from './ComponentB.vue';
> 
> export default {
>   data() {
>     return {
>       currentComponent: 'ComponentA',
>     };
>   },
>   methods: {
>     toggleComponent() {
>       this.currentComponent = this.currentComponent === 'ComponentA' ? 'ComponentB' : 'ComponentA';
>     },
>   },
>   components: {
>     ComponentA,
>     ComponentB,
>   },
> };
> </script>
> ```

-----

#### 2.5 异步组件

在Vue中，异步组件（Async Components）允许你按需加载和渲染组件，即只在需要时才加载组件的代码和资源，而不是在初始加载时就将所有组件都加载进来。

```js
components: {
	AsyncTest: () => import('./components/AsyncTest')
}
```



-----

#### 2.6 Keep-alive缓存路由组件

**定义:**

让不展示的组件进行挂载,不被销毁,避免重复的渲染DOM

`keep-alive` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们

`keep-alive`可以设置以下`props`属性：

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存
- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存
- `max` - 数字。最多可以缓存多少组件实例

> **基本用法:**
>
> ```vue
> <keep-alive>
>   <component :is="view"></component>
> </keep-alive>
> ```
>
> 使用`includes`和`exclude`：
>
> ```Vue
> <keep-alive include="a,b">
>   <component :is="view"></component>
> </keep-alive>
> 
> <!-- 正则表达式 (使用 `v-bind`) -->
> <keep-alive :include="/a|b/">
>   <component :is="view"></component>
> </keep-alive>
> 
> <!-- 数组 (使用 `v-bind`) -->
> <keep-alive :include="['a', 'b']">
>   <component :is="view"></component>
> </keep-alive>
> ```

**keep-alive 中的生命周期哪些?**

> 设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（`activated`与`deactivated`）：
>
> 1. 首次进入组件时：`beforeRouteEnter` > `beforeCreate` > `created`> `mounted` > `activated` > ... ... > `beforeRouteLeave` > `deactivated`
>
> 2. 再次进入组件时：`beforeRouteEnter` >`activated` > ... ... > `beforeRouteLeave` > `deactivated`
>
> > - `activated`：在**组件被激活时调用**。当组件被切换到**可见状态**时，该钩子函数会被触发。
> > - `deactivated`：在**组件被停用时调用**。当组件从可见状态切换到不可见状态时，该钩子函数会被触发。
> > - `beforeRouteEnter`：在**组件被缓存且激活之前调用**。在组件首次被缓存时，该钩子函数会被触发。
> > - `beforeRouteLeave`：在**组件被缓存且停用之前调用**。在组件即将被缓存之前，该钩子函数会被触发

**使用场景:**

  使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用`keepalive`

> 举个栗子:
>
> 当我们从`首页`–>`列表页`–>`商详页`–>`再返回`，这时候列表页应该是需要`keep-alive`
>
> 从`首页`–>`列表页`–>`商详页`–>`返回到列表页(需要缓存)`–>`返回到首页(需要缓存)`–>`再次进入列表页(不需要缓存)`，这时候可以按需来控制页面的`keep-alive`

在路由中设置`keepAlive`属性判断是否需要缓存

-----

#### 2.7 mixin 抽离组件公共部分

【minxin存在一些问题，Vue3提出的Composition API旨在解决这些问题】

将组件中公共的数据、方法以及生命周期钩子抽离出来保存在一个mixin.js中


>
> ```Vue
> const mixin {
> 	data() {
>  		return {
>   			commonData: '公共的数据'
>  		}
> 	},
> 	methods: {
> 		commonMethod() {
>   			console.log('公共的方法')
>  		}
> 	},
> 	mounted() {
>  		console.log('common mounted')
> 	}
> }
> ```
>
> **引入:** 
>
> 1. 全局引入:`Vue.mixin(XXX)`
> 2. 局部引入:`mixins:[XXX]`
>
> ```js
> import mixin from './mixin'
> import mixin2 from './mixin2'
> 
> new Vue({
>   mixins: [ mixin, mixin2 ],
>   data(){}
> })
> ```

**注意**:**mxin、extends 的覆盖逻辑**

1. 组件与混入的对象有**同名选项**的时候,可以**合并**,发生冲突的时候**以组件优先**
2. 同名的**生命周期钩子**可以合并为一个**数组**,都会被**调用**,**混入对象的钩子会在组件自身钩子之前调用**

**存在的一些问题**

1. 变量来源不明确，不利于阅读
2. 多mixin可能会造成命名冲突
3. mixin和组件可能出现多对多的关系，复杂度较高

-----

### 3. Vu家族

#### 3.1 vue-cli

创建项目(---------------------------参考Yi菌------------------------)

-----

#### 3.2 vue-router

(---------------------------基础的知识参考Yi菌和语雀和项目笔记day1---------------------)

**Ⅰ. 基本概念**

1. 后端路由
   概念：根据不同的用户URL请求，返回不同的内容
   本质：**URL请求地址**与**服务器资源**之间的对应关系

2. 前端路由
   概念：根据不同的用户事件，显示不同的页面内容
   本质：**用户事件**与**事件处理函数**之间的对应关系

-----

#### 3.3 vuex

专门在Vue中实现集中式状态管理的一个Vue插件,对在Vue应用中的多个组件的共享状态实现集中式的管理,式组件间的一种通信方式.

(---------------------------基础的知识参考Yi菌和语雀和项目笔记day1---------------------)

### 4. 其他问题

#### 4.1 模板引擎

-----

#### 4.2 Object.defineProperty的缺点及其优化

Vue 在 实 例 初 始 化 时 遍 历 data 中 的 所 有 属 性 ， 并 使 用`Object.defineProperty` 把这些属性全部转为 `getter/setter`。这样当追踪数据发生变化时，`setter` 会被自动调用。
>**缺点:**
>
>1. **性能开销:**深度监听,需要递归到底,一次性的计算很大,需要遍历对象的每个属性，并在每个属性上设置 getter 和 setter。当有大量属性需要劫持时，这个过程可能会导致性能下降。
>2. **无法监听属性的添加和删除: **其只能监听到属性值的变化,无法监听到属性的添加和删除操作,无法实现对整个对象的监听(`Vue.set` / `Vue.delete`)
>3. **不支持对数组和对象的监听:**只能监听**对象属性值**的变化，而无法直接**监听数组和对象的变化**。需要额外的处理。

>**优化:** 
>
>1. Proxy **直接代理整个对象而非对象属性**，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。
>
>2. Proxy 可以**监听数组的变化**。

-----

#### 4.3 数据更新了但是页面没有变化，为什么？怎么解决

> 1. **没有使用响应式属性:**Vue只能对使用了响应式属性的数据进行跟踪和更新，如果数据是在Vue实例创建之前添加的，或者是动态添加的非响应式属性，那么Vue无法监听到数据的变化，导致页面没有更新。确保所有需要被Vue跟踪的数据都是在Vue实例的`data`选项中预先定义的。
> 2. **没有正确使用Vue的更新机制：**Vue会在数据变化时通过虚拟DOM比对来更新页面，但有时候我们可能没有使用Vue提供的更新机制。比如直接使用`array[index] = value`来更新数组元素或使用`object.property = value`来更新对象属性，这样的更新方式是无法被Vue检测到的。正确的做法是使用Vue提供的响应式方法，比如`Vue.set`或`Array.prototype.splice`来更新数组，以及使用`Vue.set`或`Object.assign`来更新对象属性。
> 3. **异步更新问题：**Vue的数据更新是异步执行的，当多次对同一个数据进行修改时，Vue会将这些更新操作合并成一次更新以提高性能。但在某些情况下，由于异步更新的机制，可能会导致数据更新了但页面没有立即更新。这通常发生在Vue的生命周期钩子函数、事件处理函数或异步操作中。解决这个问题可以使用`Vue.nextTick`方法来在下一个DOM更新周期后执行回调函数，确保在数据更新后再进行操作

> **例子:**
>
> **数组的情况:**
>
> 1. 数组中直接使用索引来修改数组中的数据`vm.items[indexOfItem] = newValue` 
> 2. 直接修改数组的长度`vm.items[indexOfItem] = newValue`
>
> **对象的情况:**
>
> 1. Vue 无法检测 property 的添加或移除
> 2. property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的
>
> **解决方案:**
>
> > - 如果为对象添加少量的新属性，可以直接采用`Vue.set()`/六种数组原型上的方法`push(),pop(),shift(),unshift(),splice(),sort()`
> > - 如果需要为新对象添加大量的新属性，则通过`Object.assign()`创建新对象
> > - 如果你实在不知道怎么操作时，可采取`$forceUpdate()`进行强制刷新 (不建议)
>
> > - 确保所有需要被Vue跟踪的数据都是响应式的，使用`data`选项来定义初始数据。
> > - 使用Vue提供的响应式方法来更新数组和对象属性，确保数据变化能被Vue检测到。
> > - 在需要等待DOM更新后再执行的代码中，使用`Vue.nextTick`来确保在正确的时机进行操作
>
> PS：`vue3`是用过`proxy`实现数据响应式的，直接动态添加新属性仍可以实现数据响应式

-----

#### 4.4 虚拟DOM

**是什么**

> 它是对真实DOM的一种抽象表示，以J**avaScript对象**的形式存在。**虚拟DOM可以描述DOM结构及其属性**，并且可以进行高效的比对和更新操作。
>
> 在传统的Web开发中，当数据发生变化时，我们通常直接操作真实的DOM来更新页面，这会引起大量的DOM操作，从而导致性能下降。而**虚拟DOM的思想是在数据发生变化时，先通过对比新旧虚拟DOM的差异，然后将这些差异批量地应用到真实的DOM上，以减少对真实DOM的直接操作**，提高性能。

**为什么需要**

> 1. **提高性能：**直接操作真实DOM存在性能问题，每次更新数据都会导致DOM的重新渲染和重绘，影响页面的性能和用户体验。**虚拟DOM通过将真实DOM的操作抽象为JavaScript对象的操作**，通过批量更新和最小化DOM操作，减少了真实DOM的修改次数，从而提高页面的渲染性能。
> 2. **简化开发：**虚拟DOM使得前端开发者可以通**过更新数据来改变页面的状态**，而不需要直接操作DOM。开发者可以专注于数据的处理，而不必关心底层的DOM操作细节。这使得代码更易于理解、维护和调试，提高了开发效率。
> 3. **跨平台兼容性：**虚拟DOM可以将同一套代码在不同平台上运行，例如在浏览器端、移动端或服务器端。虚拟DOM作为一个中间层，可以将开发者编写的代码与底层的DOM操作解耦，从而提高了跨平台的兼容性和可移植性。
> 4. **更好的抽象和组件化：**虚拟DOM使得开发者可以将页面拆分为多个可复用的组件，每个组件都有自己的虚拟DOM树。通过组件化的开发方式，可以更好地管理和组织代码，提高代码的可维护性和重用性。

**原理/解析过程**

> 1. **初始渲染：将数据和模板结合生成虚拟DOM树。**虚拟DOM树是一个以JavaScript对象的形式存在的抽象表示，它包含了组件的结构、属性和事件等信息。
> 2. **虚拟DOM树构建：根据模板的结构，递归地创建虚拟DOM树。**对于每个DOM节点，生成相应的虚拟DOM节点，并为其设置属性、事件和子节点等信息。
> 3. 虚拟DOM树更新：当数据发生变化时，会重新生成一棵新的虚拟DOM树。新的虚拟DOM树会与之前的虚拟DOM树进行对比，找出两者之间的差异。这个对比过程称为虚拟DOM的diff算法。
> 4. 差异比对：对比新旧虚拟DOM树的差异，找出需要进行更新的节点。通过比对节点的类型、属性和子节点等信息，确定节点的变化类型，如新增节点、删除节点、替换节点或更新节点。
> 5. 批量更新：将差异应用到真实的DOM上，进行批量的DOM操作，最小化对真实DOM的修改。这个过程被称为虚拟DOM的patch过程。
> 6. 页面更新：将更新后的虚拟DOM树渲染到页面上，实际上就是将更新后的DOM节点替换原有的DOM节点，完成页面的更新。

-----

#### 4.5  diff算法

Diff算法的基本思路是递归地比较新旧虚拟DOM树的节点，按照节点类型、属性和子节点等信息进行比对。

> 1. 只比较同一层级，不跨层比较
>
> 2. tag不同，直接删除重建，不再深度比较
>
> 3. tag和key，两者都相同，则认为是相同节点，不再深度比较
>

> **Diff算法的一般流程**：
>
> 1. 比较根节点：首先比较新旧虚拟DOM树的根节点，判断它们的节点类型是否相同。如果不同，则说明根节点需要被替换。
> 2. 比较属性：如果新旧节点的类型相同，就比较它们的属性。对比属性的变化，确定哪些属性需要被更新。
> 3. 比较子节点：如果新旧节点的类型相同，并且有子节点，则递归地比较它们的子节点。根据子节点的变化情况，进行增加、删除或更新操作。
> 4. 唯一标识：在比较子节点时，为了提高效率，通常会给每个节点设置唯一标识（Key）。通过唯一标识，可以更准确地判断新旧节点之间的对应关系，避免不必要的操作。
>
> Diff算法的优化策略：
>
> 1. 同层比较：在比较子节点时，Diff算法会尽量在同层级进行比较，而不会跨层级遍历。这样可以减少比较的次数，提高算法的效率。
> 2. Key优化：通过给节点设置唯一标识（Key），可以在比较子节点时快速定位对应关系，避免不必要的移动和更新操作。
> 3. 列表优化：针对列表的比较，Diff算法会使用一些优化策略，如增加和删除节点的复用，减少节点的移动操作，从而提高列表的渲染效率。

-----

#### 4.7  Vue 中key 的作用和原理

> **是什么: ** key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点

> 1. **v-if:** Vue 通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。
>
> 2. **v-for:**用v-for更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue不会移动DOM元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个key值，来以便Vue 跟踪元素的身份，从而高效的实现复用。这个时候key的作用是为
>
>    了高效的更新渲染虚拟DOM。
>
> 3. key是为Vue中vnode的唯一标记，通过这个key，diff操作可以更准确、更快速
>
> 4. 动态组件（`<component>`）
>
> 5. 路由切换（`Vue Router`）
>
> 6. 过渡动画（`Vue Transition`）
>
> - 提高列表渲染的性能和效率，减少不必要的DOM操作。
> - 优化条件切换，减少元素的创建和销毁，保持状态和局部状态。
> - 保持元素的身份标识，确保正确的复用和更新。

> **设置key值一定能提高diff效率吗？**
>
> 设置 `key` 值并不一定能够提高 diff 效率。`key` 的主要作用是帮助 Vue 识别列表中的每个节点，在进行列表渲染时，Vue 使用 `key` 来跟踪每个节点的标识，从而在更新列表时能够高效地重用和移动节点，减少 DOM 操作。
>
> 然而，`key` 的效果并不是绝对的。其提高 diff 效率的前提是列表中的节点顺序相对稳定，并且节点的 `key` 值唯一且稳定不变。如果节点顺序经常变动或 `key` 值不唯一，那么设置 `key` 的效果将不明显，甚至可能导致 diff 的性能变差。
>
> 此外，`key` 值的选择也需要慎重，不宜过于依赖索引值或随机数，最好选择唯一且稳定的标识符，如数据中的唯一 ID。

-----

#### 4.8 vue的基本原理

> Vue的基本原理是基于**响应式数据绑定**和**虚拟DOM**的方式实现的
>
> 1. **响应式数据绑定：**Vue.js 使用了数据劫持和观察者模式来实现响应式数据绑定。它通过使用 Object.defineProperty() 方法来追踪数据的变化，当数据发生变化时，它会自动更新相关的视图。
> 2. **组件化架构：**Vue.js 将用户界面划分为多个组件，每个组件都封装了自己的逻辑和视图。这样的组件化架构使得开发者能够更好地组织和复用代码，提高了应用的可维护性和可扩展性。
> 3. **虚拟 DOM：**Vue.js 使用虚拟 DOM 来优化页面渲染性能。它将页面抽象成一个轻量级的 JavaScript 对象树，并通过对比新旧虚拟 DOM 树的差异，最小化实际 DOM 操作，从而提高了页面的渲染效率。
> 4. **生命周期钩子**：Vue.js 提供了一系列的生命周期钩子函数，允许开发者在组件的不同阶段执行自定义的逻辑。这些钩子函数包括创建、更新、销毁等阶段，开发者可以利用它们来进行必要的初始化、数据处理或清理操作。
> 5. **指令系统：**Vue提供了一套强大的指令系统，用于扩展HTML的功能。指令可以用于操作DOM、响应用户事件、进行条件渲染等。开发者可以根据需要自定义指令，或者使用Vue提供的内置指令来实现特定的功能。

-----

#### 4.9 SPA

**什么是SPA**

> SPA由一个单独的HTML页面组成，所有的内容和资源都在该页面中加载和渲染。页面切换时只更新部分内容，而不需要重新加载整个页面。

**SPA和MPA的区别**

> MPA由多个HTML页面组成，每个页面对应一个不同的URL。每次页面切换都需要加载一个新的页面，页面之间的跳转需要通过超链接或服务器的重定向来实现。
>
> |                 | 单页面应用（SPA）         | 多页面应用（MPA）                   |
> | :-------------- | :------------------------ | ----------------------------------- |
> | 组成            | 一个主页面和多个页面片段  | 多个主页面                          |
> | 刷新方式        | 局部刷新                  | 整页刷新                            |
> | url模式         | 哈希模式                  | 历史模式                            |
> | SEO搜索引擎优化 | 难实现，可使用SSR方式改善 | 容易实现                            |
> | 数据传递        | 容易                      | 通过url、cookie、localStorage等传递 |
> | 页面切换        | 速度快，用户体验良好      | 切换加载资源，速度慢，用户体验差    |
> | 维护成本        | 相对容易                  | 相对复杂                            |

**SPA的优缺点**

> **优点：**
>
> 1. **流畅的用户体验**：SPA通过动态加载内容和局部更新，实现了流畅的用户体验。页面切换快速，不需要重新加载整个页面，只更新必要的部分，用户感觉像在使用原生应用程序。
> 2. **较少的数据传输：**SPA使用前端路由进行页面切换，只加载所需的数据，减少了不必要的数据传输。这可以提高性能和节省带宽，尤其在移动设备上更为明显。
> 3. **前后端分离：**SPA将前端与后端逻辑分离，前端负责处理视图和交互，后端负责提供数据接口。这样可以更好地分工合作，提高开发效率，并支持团队间的并行开发。
> 4. **可维护性和可扩展性：**由于SPA采用了组件化开发模式，将应用程序拆分为多个可重用的组件，使得代码更加模块化、可维护性更高。同时，SPA的架构使得应用程序易于扩展和演进。
> 5. **跨平台开发：**SPA可以在多个平台和设备上运行，无论是桌面、移动端还是浏览器，只需编写一次代码即可。这有助于降低开发成本和提高开发效率。
>
> **缺点：**
>
> 1. **初始加载时间较长：**由于SPA需要一次性加载所有必要的资源，初始加载时间可能较长，特别是当应用程序较大时。用户可能需要等待较长时间才能看到应用程序的初始界面。
> 2. **SEO（搜索引擎优化）问题：**由于SPA动态加载内容，搜索引擎爬虫在初始加载时可能无法获取完整的页面内容，从而影响了网页在搜索引擎结果中的排名。需要采取额外的措施，如预渲染或服务器端渲染，以解决这个问题。
> 3. **浏览器兼容性问题：**某些较老版本的浏览器可能对一些新的Web技术（如ES6语法、HTML5 API等）支持不完全，导致SPA在这些浏览器上运行不正常或出现兼容性问题。需要进行兼容性测试和处理。
> 4. **内存占用较高：**SPA将整个应用程序加载到浏览器内存中，并在运行过程中保持这些资源。当应用程序较大且用户在同一个页面停留时间较长时，可能

**如何给SPA做SEO**

> 1. **预渲染（Prerendering）或服务器端渲染（Server-Side Rendering=SSR）：**SPA通常在客户端动态生成内容，这使得搜索引擎难以获取完整的页面内容。通过预渲染或服务器端渲染，**可以在服务端生成完整的HTML页面，并将其提供给搜索引擎爬虫**。这样可以确保搜索引擎能够正确地抓取和索引您的网页内容。
>
> 2. **设置合适的meta标签：**在每个页面中设置合适的meta标签，包括标题（title）、描述（description）、关键词（keywords）等。这些标签可以提供给搜索引擎关于页面内容的相关信息，帮助搜索引擎理解和分类您的网页。
>
> 3. **使用合理的URL结构：**使用语义化的URL结构，包含关键字，使其更容易被搜索引擎理解和索引。遵循RESTful风格的URL设计原则，让URL表达资源和操作的关系。
>
> 4. **静态化:**
>
>    (1) 使用**静态站点生成器**将动**态内容生成为静态HTML文件**。静态站点生成器会在构建过程中通过预先定义的模板和数据源生成静态HTML页面，并将其部署到**服务器上**。一些流行的静态站点生成器包括Jekyll、Gatsby、Hugo等。(2)一种是通过WEB服务器的 `URL Rewrite`的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果
>
> 5. **使用`Phantomjs`针对爬虫处理**

**SPA首屏加载速度慢如何解决**

**是什么**

> 首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容
>
> 首屏加载可以说是用户体验中**最重要**的环节

**加载慢的原因**

> 1. **资源文件体积过大：**如果SPA应用的代码和资源体积过大，会导致初始加载时需要下载的内容过多，从而造成加载速度慢。解决方法包括代码优化、资源压缩和按需加载等策略，以减少应用的体积。
> 2. **依赖过多：**如果SPA应用依赖的外部库和组件过多，每个依赖都需要下载和加载，会增加首屏加载时间。解决方法是仔细评估和选择所需的依赖，尽量减少不必要的依赖，或者使用按需加载的方式加载依赖。
> 3. **渲染逻辑复杂：**如果SPA应用在首屏渲染时需要执行复杂的逻辑和计算，会导致渲染时间较长。解决方法是优化渲染逻辑，尽量减少计算量和DOM操作，提高渲染效率。
> 4. **加载资源不合理：**如果SPA应用将所有资源都一次性加载，或者资源是否重复发送请求去加载了会导致首屏加载速度慢。解决方法是将非关键的资源延迟加载，可以通过懒加载或异步加载的方式，只在需要时再加载相应的资源。
> 5. **缓存策略不合理：**如果SPA应用的资源没有正确地设置缓存策略，每次访问都需要重新下载资源，增加了加载时间。解决方法是通过合理设置资源的缓存策略，使得重复访问时可以从缓存中获取资源，减少加载时间。
> 6. **网络延迟：**如果网络延迟较高，会导致SPA应用的资源下载时间较长。解决方法是优化网络请求，使用CDN加速、压缩资源、减少请求次数等方式来减少网络延迟。

**解决方案**

> - **路由懒加载**
>
>   >  在路由配置中使用函数的方式来异步加载组件,组件会在路由被访问时才会进行加载。这样可以将初始加载时的资源减少到最小，只加载当前需要的路由组件，提高了应用的加载速度。同时，当路由被访问时，会自动按需加载对应的组件，并进行渲染。
>
> - **静态资源本地缓存**
>
>   > 1. 设置 HTTP 缓存头：在服务器的响应中设置适当的 HTTP 缓存头，包括 `Cache-Control`、`Expires`、`Last-Modified`、`ETag` 等，用于指示浏览器如何缓存资源。
>   > 2. 设置文件名版本号：在静态资源的文件名中添加版本号或者哈希值，每当静态资源内容发生变化时，修改文件名，从而强制浏览器重新下载最新的资源。
>   > 3. 使用缓存清单：通过使用缓存清单（Cache Manifest）或 Service Worker 技术，可以将静态资源的列表和版本信息保存在客户端，并在离线状态下从本地缓存中加载资源。
>   > 4. 设置缓存过期时间：通过设置缓存头中的 `Cache-Control` 或 `Expires` 字段，指定静态资源的缓存过期时间，让浏览器在该时间段内直接从本地缓存中加载资源。
>
> - **UI框架按需加载**
>
>   > 在日常使用`UI`框架，例如`element-UI`、或者`antd`，我们经常性直接引用整个`UI`库
>   >
>   > 但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用
>
> - **图片资源的压缩**
>
>   > 图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素
>   >
>   > 对于所有的图片资源，我们可以进行适当的压缩
>   >
>   > 对页面上使用到的`icon`，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻`http`请求压力。
>
> - **组件重复打包**
>
>   > 假设`A.js`文件是一个常用的库，现在有多个路由使用了`A.js`文件，这就造成了重复下载
>   >
>   > **解决方案：**在`webpack`的`config`文件中，修改`CommonsChunkPlugin`的配置`minChunks: 3`
>   >
>   > `minChunks`为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件
>
> - **开启GZip压缩**
>
>   > 拆完包之后，我们再用`gzip`做一下压缩
>
> - **使用SSR**
>
>   > SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器
>   >
>   > 从头搭建一个服务端渲染是很复杂的，`vue`应用建议使用`Nuxt.js`实现服务端渲染
>
>![首屏优化](E:\Front\八股文\My八股文\八股图\首屏优化.png)

-----

#### 4.10 **双向数据绑定的原理**

-----

#### 4.11 **Vue 中封装的数组方法有哪些，其如何实现页面更新**

> 1. push：将元素添加到数组的末尾。
> 2. pop：移除数组的最后一个元素。
> 3. shift：移除数组的第一个元素。
> 4. unshift：将元素添加到数组的开头。
> 5. splice：从数组中移除或添加元素。
> 6. sort：对数组进行排序。
> 7. reverse：反转数组元素的顺序。

(--------------------------------------------------------------源码没看-----------------------------------------------------------------------------)

-----

#### 4.12 子组件可以直接改变父组件的数据吗？

> ​		子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。
>
> ​		每次父级组件发生更新时，子组件中所有的 `prop`都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。
>
> ​		Vue 提倡单向数据流，即父级 `props` 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。
>
> > 如果子组件需要修改父组件的数据，可以通过以下方式实现：
> >
> > 1. 使用事件触发：子组件通过 `$emit` 方法触发一个自定义事件，并传递要修改的数据作为参数。在父组件中监听该事件，并在事件处理函数中修改数据。
> > 2. 使用 `v-model`：如果父组件传递给子组件的数据需要进行双向绑定，可以使用 `v-model` 指令。`v-model` 会自动创建一个名为 `value` 的 prop，并监听子组件的 `input` 事件来更新父组件的数据。
> > 3. 使用 `.sync` 修饰符：Vue 提供了 `.sync` 修饰符，可以简化父子组件之间的双向绑定。通过在子组件中使用 `.sync` 修饰符绑定一个父组件的属性，并通过 `$emit` 触发一个带有 `.sync` 后缀的事件来更新父组件的数据。

-----

#### 4.13 Vue 的优点

> 1. 简洁易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
> 2. 双向数据绑定：Vue.js 提供了数据的双向绑定机制，即当数据发生变化时，视图会自动更新，而当视图发生变化时，数据也会相应更新。
> 3. 组件化开发：Vue.js 鼓励组件化开发，将页面拆分为多个独立的组件，每个组件具有自己的逻辑和样式，可以复用和组合。这样的组件化开发方式使得代码更加模块化、可维护性更强。
> 4. 轻量高效：Vue.js 的核心库体积小巧，加载速度快。Vue.js 采用虚拟 DOM 技术，在更新视图时只更新实际发生变化的部分，提高了性能。
> 5. 生态丰富：Vue.js 拥有活跃的社区和庞大的生态系统，提供了丰富的插件和扩展，可以满足各种开发需求。同时，Vue.js 与其他常用的库和框架（如 Vue Router、Vuex、axios 等）有很好的兼容性。
> 6. 渐进式框架：Vue.js 是一个渐进式框架，可以根据项目的需求逐步引入，可以作为一个简单的库使用，也可以构建复杂的单页应用。这种灵活性使得 Vue.js 适用于各种规模的项目
> 7. 运行速度快

-----

#### 4.14 assets 和static 的区别

> **相同点：** assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下
>
> **不同点:**
>
> 1.  "assets" 目录：
>
>     - 通常用于存放需要经过构建过程处理的静态资源，如样式表（CSS）、脚本文件（JS）和图片等。
>
>     - 在开发环境下，这些资源会被 webpack 进行处理和打包，并通过模块化的方式引入到项目中。
>
>     - 在生产环境下，这些资源会被进行压缩、合并和优化，最终生成用于部署的静态文件。
>
> 2. "static" 目录：
>
>     - 用于存放静态资源，这些资源不经过构建过程，直接复制到输出目录（如 dist 目录）中。
>
>     - 在开发环境和生产环境下，这些资源都会被直接复制到输出目录中，不会经过任何处理。
>
>     - 一般用于存放一些不需要经过打包处理的静态文件，如第三方库、字体文件、音频、视频等。
>
> 总的来说，"assets" 目录中的静态资源**需要经过构建和处理**，而 "static" 目录中的静态资源则直接复制到输出目录中，**不经过构建过程**。选择使用哪个目录取决于资源是否需要经过构建处理，以及是否需要在开发环境下使用模块化的方式引入
>
> > **建议:**将项目中 template 需要的样式文件js 文件等都可以放置在assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传

-----

#### 4.15 delete 和Vue.delete 删除数组的区别

> `delete` 是用于**删除对象属性的操作符**,不会触发 Vue 的响应式更新机制
>
>  `Vue.delete` 是 Vue.js 提供的一个方法，用于**删除 Vue 实例**或**组件的响应式数组的元素**,并触发响应式更新。

-----

#### 4.16 Vue 模版编译原理

-----

#### 4.17 vue初始化页面闪动问题

(-----------------------------------------------------------------见v-clock指令---------------------------------------------------------------------)

-----

#### 4.18  v-if 和v-for 哪个优先级更高？如果同时出现，应如何优化?

> `v-for`优先级是比`v-if`高
>
> > 1. 永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）
> > 2. 如果避免出现这种情况，则在外层嵌套`template`（页面渲染不生成`dom`节点），在这一层进行v-if判断，然后在内部进行v-for循环
> > 3. 如果条件出现在循环内部，可通过计算属性`computed`提前过滤掉那些不需要显示的项

-----

#### 4.19 对vue组件化理解和插件有什么区别

> **组件是什么:**
>
> ​	用来实现局部功能的代码和资源的集合
>
> **优势:**
>
> - 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现
> - 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单
> - 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级
>
> **插件是什么:**
>
> ​	插件（Plugin）是一种扩展机制，用于为Vue应用添加全局功能。通常，插件可以添加全局指令、全局过滤器、全局组件、原型方法、实例方法等
>
> **区别:**
>
> - 编写形式
>
> - 注册形式
>
> - 使用场景
>
>   组件 `(Component)` 是用来构成你的 `App` 的业务模块，它的目标是 `App.vue`
>
>   插件 `(Plugin)` 是用来增强你的技术栈的功能模块，它的目标是 `Vue` 本身
>
>   简单来说，插件就是指对`Vue`的功能的增强或补充

-----

#### 4.20 Vue 子组件和父组件执行顺序

> 1. 父组件的创建和挂载：首先，父组件会经历创建阶段，包括实例化、数据初始化、生命周期钩子调用等。然后，父组件会被挂载到DOM中，即父组件的模板会被渲染成实际的HTML并插入到页面中。
> 2. 子组件的创建和挂载：**在父组件挂载完成后**，Vue会开始处理父组件中的子组件。子组件会按照父组件模板中的组件标签顺序进行创建和挂载。每个子组件都会经历自己的创建阶段和挂载阶段。
> 3. 子组件的生命周期钩子调用：在子组件被创建和挂载后，会依次调用子组件的生命周期钩子函数。子组件的生命周期钩子函数包括`beforeCreate`、`created`、`beforeMount`、`mounted`等。
> 4. 父组件的生命周期钩子调用：在子组件的生命周期钩子函数执行完毕后，会回到父组件中继续执行剩余的生命周期钩子函数。父组件的生命周期钩子函数包括`beforeCreate`、`created`、`beforeMount`、`mounted`等。
>
> 总体上，**父组件的生命周期钩子函数先于子组件的生命周期钩子函数执行**。父组件先完成**创建和挂载**，然后才处理**子组件的创建和挂载**。在整个过程中，子组件的生命周期钩子函数执行顺序与它们在父组件模板中的顺序一致。
>
> > 加载渲染过程：
> >
> > 1. 父组件 beforeCreate
> >
> > 2. 父组件 created
> >
> > 3. 父组件 beforeMount
> >
> > 4. 子组件 beforeCreate
> >
> > 5. 子组件 created
> >
> > 6. 子组件 beforeMount
> >
> > 7. 子组件 mounted
> >
> > 8. 父组件 mounted
> >
> > **更新过程：**
> >
> > 1. 父组件 beforeUpdate
> >
> > 2. 子组件 beforeUpdate
> >
> > 3. 子组件 updated
> >
> > 4. 父组件 updated
> >
> > **销毁过程：**
> >
> > 1. 父组件 beforeDestroy
> >
> > 2. 子组件 beforeDestroy
> >
> > 3. 子组件 destroyed
> >
> > 4. 父组件 destoryed

-----

#### 4.21 路由的hash 和history 模式的区别

> Vue-Router 有两种模式：hash 模式和 history 模式。默认的路由模式是hash 模式。
>
> 它们在 **URL 的展示**和**路由跳转**的方式上有所区别。
>
> 1. Hash 模式：
>
>    - URL 格式：在 URL 中以 `#` 开头，例如 `http://example.com/#/path`
>    - 原理：当 URL 中的哈希值发生变化时，不会导致浏览器向服务器发送请求，而是触发浏览器的 `hashchange` 事件。前端路由通过监听 `hashchange` 事件来实现路由的变化和响应。使用onhashchange()事件的好处就是，**在页面的 hash 值发生变化时，无需向后端发起请求**，window 就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash 值变化对应的 URL 都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash 值和对应的URL 关联起来了。
>    - 优点：兼容性好，支持在不同浏览器和旧版浏览器中使用；部署简单，不需要服务器端配置。
>    - 缺点：URL 中的哈希值较长，不直观，不利于 SEO。
>    - 特定:   hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。
>
> 2. History 模式：
>
>    - URL 格式：不包含 `#`，直接使用路径，例如 `http://example.com/path`, 它使用的是传统的路由分发模式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理
>
>    - 原理：通过 HTML5 History API 中的 `pushState` 或 `replaceState` 方法改变 URL，并在服务器端进行相应的配置，使得在浏览器发送请求时能够正确地响应对应的页面。前端路由通过监听浏览器的 `popstate` 事件来实现路由的变化和响应。
>
>      > **修改历史状态：** 包括了 HTML5 History Interface 中 新增 的`pushState()` 和 `replaceState()` 方法，这两个方法应用于**浏览器的历史记录栈**，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器**不会立即向后端发送请求**。如果要做到改变url 但又不刷新页面的效果，就需要前端用上这两个API。
>      >
>      > 切换历史状态： 包括 forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。
>
>    - 优点：URL 清晰、直观，对 SEO 更友好；无需额外的字符，可以使用相对短的路径。
>
>    - 缺点：需要服务器端配置支持，否则如果没有相应的路由或资源,在刷新页面或直接访问路由时会出现 404 错误；不兼容较旧的浏览器。
>
>    - 特点:  当 使 用 history 模 式 时 ， URL 就 像 这 样 ：http://abc.com/user/id。相比 hash 模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。API： history api 可以分为两大部分，切换历史状态和修改历史状态
>
> 综上所述，Hash 模式和 History 模式在 URL 的展示方式和浏览器行为上有所不同。Hash 模式兼容性好但不利于 SEO，而 History 模式对 SEO 更友好但需要服务器端支持。选择使用哪种模式取决于项目需求和对 SEO 的重视程度。
>
> > **两种模式的对比:**
> >
> > - 调用 `history.pushState()` 相比于直接修改 hash，存在以下优势:`pushState()` 设置的新 URL 可以是与当前 URL 同源的任意 URL；而hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的URL；
> > - `pushState()` 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
> > - `pushState()` 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
> > - `pushState()` 可额外设置 title 属性供后续使用。
> > - hash 模式下，仅hash 符号之前的url 会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，前端的url 必须和实际向后端发起请求的url 一致，如果没有对用的路由处理，将返回 404 错误。
> >
> > hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。

-----

#### 4.22 Vue-router 跳转和 location.href 有什么区别

> Vue Router 跳转和 `location.href` 的区别在于它们实现路**由跳转的方式**和**对应的效果**。
>
> 1. Vue Router 跳转：
>    - 使用 Vue Router 提供的**编程式导航**方法，例如 `router.push`、`router.replace`、`router.go` 等，或通过 `<router-link>` 组件来触发路由跳转。
>    - 通过 Vue Router 跳转时，**不会触发浏览器的刷新**，**页面内容会根据路由变化进行动态更新**，但整个页面的状态和 Vue 实例的状态会被保留，不会重新加载页面，因此可以实现单页应用（SPA）的效果。
>    - Vue Router 通过监听路由的变化，并**通过组件的切换来**渲染对应的页面内容，提供了更好的用户体验和前端路由管理能力。
> 2. `location.href` 跳转：
>    - 使用 JavaScript 中的 `location.href` 或 `location.replace` 方法进行页面跳转。
>    - 通过 `location.href` **跳转会触发浏览器的刷新**，整个页面会重新加载，包括重新执行 JavaScript 代码、重新请求资源等。
>    - 这种方式会导致**页面的状态和 Vue 实例的状态丢失**，整个页面重新加载，因此不适用于单页应用场景。
>
> 综上所述，Vue Router 跳转和 `location.href` 在实现方式和效果上有明显的区别。Vue Router 跳转适用于单页应用，实现了前端路由管理和页面内容的动态更新，而 `location.href` 跳转是传统的页面跳转方式，会触发浏览器的刷新，页面会重新加载。选择使用哪种方式取决于项目需求和所需的页面行为。

-----

#### 4.23 Vuex 和 localStorage 的区别

> Vuex和localStorage是两种在Vue应用中用于**数据存储**和**管理的不同机制**，它们有以下区别：
>
> 1. 数据持久性：
>    - Vuex：Vuex是Vue的状态管理库，用于在应用程序中进行集中式的状态管理。Vuex中的数据是在**内存中存储**的，**只在当前会话期间保持有效**，刷新页面或关闭浏览器后数据会丢失。
>    - localStorage：localStorage是浏览器提供的Web存储机制，可以将数据以键值对的形式**永久存储在浏览器中**。即使刷新页面或关闭浏览器，数据也会被保留。
>
> 2. 数据共享：
>    - Vuex：Vuex中的数据可以在应用程序的不同组件之间共享和访问。通过定义全局的状态(state)、操作(mutations)、行为(actions)和获取(getters)，组件可以通过Vuex的API来读取和更新共享的数据。
>    - localStorage：localStorage存储的数据是全局可访问的，但没有提供像Vuex那样的集中式管理和数据响应能力。在不同组件之间共享localStorage的数据需要手动进行数据读取和更新，没有内置的机制来确保数据的一致性和同步。
>
> 3. 数据更新和响应：
>    - Vuex：**Vuex中的数据是响应式的**，当数据发生变化时，与该数据相关的组件会自动更新。Vuex提供了一些特定的方法（如mutations和actions）来确保数据的更新是通过特定的方式进行的，以便进行状态变更的追踪和管理。
>    - localStorage：localStorage存储的数据**不具备响应性**，即使数据发生变化，相关的组件不会自动更新。需要手动监听和处理数据的变化，并在变化时触发相应的操作。
>
> 4. 存储方式：
>     - Vuex是在内存中**存储**
>     - localStorage将数据以键值对的形式**永久存储在浏览器中**。只能存储字符串类型的数据，存储对象需要 JSON 的stringify 和parse 方法进行处理。 读取内存比读取硬盘速度要快
>
>     综上所述，Vuex和localStorage在数据持久性、数据共享和数据更新响应等方面有明显的区别。Vuex适用于管理应用程序的共享状态和实现数据的响应式更新，而localStorage适用于持久性数据存储和全局共享，但需要手动管理和更新数据。选择使用哪种机制取决于项目的需求和数据管理的复杂性。
>     
>     
>
> 对于不变的数据确实可以用localstorage 可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage 无法做到，原因就是区别 1。

-----

#### 4.24 为什么要用 Vuex

> 由于**传参的方法**对于**多层嵌套的组件**将会非常繁琐，并且对于**兄弟组件间的状态传递无能为力**。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致**代码无法维护**。所以需要**把组件的共享状态抽取出来**，以一个**全局单例模式管理**。在这种模式下，组件树构成了一个巨大的"视图"，不管在树的哪个位置，**任何组件都能获取状态或者触发行为**。另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。

-----

#### 4.25 Vuex和单纯的全局对象有什么区别

> 1. 显式的状态管理：Vuex提供了一种显式的状态管理方案。它通过定义状态、mutations、actions等概念，明确规定了状态的修改方式和数据流动的规则。这使得状态管理更加可控和可预测，减少了状态管理的混乱和不一致性。
> 2. **响应式更新：**Vuex使用Vue的响应式系统来管理状态。**当状态发生变化时，相关的组件会自动进行更新，无需手动触发更新**。这种响应式机制可以有效减少手动操作和跟踪状态变化的工作量，提高开发效率。
> 3. **中央化的状态管理：**Vuex将状态集中存储在一个单独的地方，即store。这样，所有组件都可以直接访问和修改store中的状态，避免了状态分散和传递的问题。而**全局对象则可能分散在各个模块和组件**中，导致状态管理的复杂性和困难。
> 4. **插件和工具支持：**Vuex提供了一系列插件和开发工具，例如Vue Devtools，可以辅助开发者进行状态调试、性能优化等工作。这些工具和插件为状态管理带来了更好的开发体验和工具支持。
> 5. **异步操作和状态变更的扩展：**Vuex提供了actions和getters等机制，可以处理异步操作和派生状态的计算。这使得在处理复杂业务逻辑和状态变更时更加灵活和可扩展

-----

#### 4.26 为什么 Vuex 的 mutation 中不能做异步操作？

> 在Vuex的mutation中不能直接进行异步操作的主要原因是**确保状态的变更是同步的**和**可追踪的**。
>
> Vuex的核心原则之一是**"状态的变更必须通过提交mutation来进行**"。**Mutation是同步操作，它用于修改状态的唯一途径**。当在mutation中进行异步操作时，会破坏这个原则，导致状态的变更变得不可追踪和不可预测。
>
> 异步操作包括例如发起网络请求、定时器、Promise等，**它们的执行时间是不确定的**，无法保证在mutation完成之前完成。如果允许在mutation中进行异步操作，那么无法保证状态的变更时机，可能导致状态的不一致性和可追踪性的丧失。
>
> 为了解决异步操作的问题，Vuex提供了另外一种机制，即Actions。Actions可以用于处理异步操作，可以在action中进行异步操作，然后**再通过commit提交mutation来修改状态**。这样可以确保状态的变更是同步的，而异步操作的执行可以在action中进行。
>
> 因此，如果需要进行异步操作，应该将异步操作放在Vuex的action中，然后再通过commit提交mutation来修改状态。这样可以保持状态的同步性和可追踪性，遵循Vuex的设计原则。

-----

#### 4.27 Vue项目中你是如何解决跨域的呢？

> **是什么：**
>
> > 跨域本质是浏览器基于**同源策略**的一种安全手段
> >
> > 同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能
> >
> > 所谓同源（即指在同一个域）具有以下三个相同点
> >
> > - 协议相同（protocol）
> > - 主机相同（host）
> > - 端口相同（port）
> >
> > 反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域
>
> > 一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用postman请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。
>
> **解决：**
>
> > 1. **CORS（跨域资源共享）**：是一个系统，它由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应。
> >
> >    如果目标服务器支持CORS，可以在服务器端设置响应头信息，允许跨域请求。通过在响应头中添加`Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`等相关字段，来指定允许的跨域访问规则。
> >
> > 2. **JSONP（JSON with Padding）**：JSONP是一种跨域请求的方法，通过动态创建`<script>`标签，将请求包装为一个回调函数，将返回的数据作为函数参数传递到客户端。在Vue中可以使用`axios`库等支持JSONP的方式进行请求。
> >
> > 3. **Proxy**
> >

-----

#### 4.28 vue项目本地开发完成后部署到服务器后报404是什么原因呢

> 

-----

#### 4.29 你是怎么处理vue项目中的错误的？

> 

-----

### 5. Vue3

#### 5.1 Vue3.0性能提升主要是通过哪几方面体现的？

> 

-----

#### 5.2 vue3有了解过吗？能说说跟vue2的区别吗？

> 

-----

### 52.重排和重绘的区别？什么情况下会导致，如何减少？

> **区别：**
>
> ​		当浏览器在渲染页面的过程中，渲染树中的一部分或者全部，因为**元素的尺寸、布局、显隐等改变而需要重新构建**。这个过程我们称之为重排。
>
> ​	**当渲染树中的一些元素更新某些属性时**，且这些属性只影响**元素的外观、风格，不影响页面布局**的会触发重新绘制，我们称之为重绘。
>
> ​	浏览器渲染页面时至少会触发一次重绘，重绘不一定需要重排，但是重排一定会触发重绘。
>
> **重排触发的条件列举：**
> 	1.调整浏览器窗口大小
> 	2.改变字体
> 	3.增加或者移除样式表
> 	4.内容导致的页面变化，比如input/textarea等
> 	5.css伪类，如:hover,actived,visited等
> 	6.操作 class 属性
> 	7.操作 DOM
> 	8.计算 offsetWidth 和 offsetHeight 属性
> 	9.设置 style 属性的值
> 	10.改变display属性
>
> **重绘触发的条件列举：**
> 	1.各种设计颜色的属性修改
> 	2.text-align的修改
> 	3.:hover引起的颜色等不导致页面回流的style变动
> 	4.以上重排条件触发时会触发重绘
>
> **减少重排和重绘：**
> 	1.尽量在DOM树的末端设置元素样式，改变class名来实现
> 	2.避免多次设置内联样式
> 	3.减少使用table布局
> 	4.避免css的javascript
> 	5.在scroll/resize 等频发触发的事件中增加函数节流
> 	4.操作动画元素时多使用postion:absolute 或者translate3d 









