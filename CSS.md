# CSS

### 1.说说你对盒子模型的理解?

> **是什么**
>
> > 当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）
> >
> > 一个盒子由四个部分组成：`content`、`padding`、`border`、`margin`
> >
> > `content`，即**实际内容**，显示文本和图像
> >
> > `boreder`，即**边框**，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成
> >
> > `padding`，即内边距，清除内容周围的区域，**内边距是透明的**，取值不能为负，受盒子的`background`属性影响
> >
> > `margin`，即外边距，在元素外创建额外的空白，**空白通常指不能放其他元素的区域**
>
> **标准盒子模型**
>
> > - 盒子总宽度 = width + padding + border + margin;
> > - 盒子总高度 = height + padding + border + margin
> >
> > 也就是，`width/height` 只是内容高度，不包含 `padding` 和 `border`值
> >
> > 所以上面问题中，设置`width`为200px，但由于存在`padding`，但实际上盒子的宽度有240px
>
> **IE 怪异盒子模型**
>
> > - 盒子总宽度 = width + margin;
> > - 盒子总高度 = height + margin;
> >
> > 也就是，`width/height` 包含了 `padding`和 `border`值
>
> **Box-sizing**
>
> > CSS 中的 `box-sizing` 属性定义了引擎应该如何计算`一个元素`的总宽度和总高度
> >
> > 语法：
> >
> > ```css
> > box-sizing: content-box|border-box|inherit:
> > ```
> >
> > - content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致
> > - border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致
> > - inherit 指定 box-sizing 属性的值，应该从父元素继承
>
> **Other**
>
> > > padding会影响盒子大小
> > >
> > > 盒子本身没有指定width/height属性，则此时padding不会撑开盒子大小
> >
> > > 让**块级**盒子水平居中
> > >
> > > 外边距典型应用
> > >
> > > 1. 盒子必须指定了宽度（width）
> > > 2. 盒子左右的外边距都设置为auto
> > >
> > > ```css
> > > margin: 0 auto;
> > > margin: auto;
> > > margin-left: auto; margin-right: auto;
> > > ```
> >
> > > 让**行内元素、行内块**元素水平居中
> > >
> > > 给**父元素添加**
> > >
> > > ```css
> > > text-align: center;
> > > ```

### 2.css选择器有哪些？优先级？哪些属性可以继承？

> [面试官](https://vue3js.cn/interview/css/selector.html#%E4%B8%80%E3%80%81%E9%80%89%E6%8B%A9%E5%99%A8)
>
> **不可以继承的元素怎么办**
>
> > 当一个属性不是继承属性的时候，我们也可以通过将它的值设置为`inherit`来使它从父元素那获取同名的属性值来继承。
> >
> > 使用`inherit`关键字可以强制继承一个通常不会被继承的属性 使用`initial`关键字卡可以将某个**属性**重制成属性的默认初始值注意与`auto`的区别
>
> **伪类选择器与伪元素选择器**
>
> > **伪类选择器**用于选择处于**特定状态或具有特定属性**的元素。它们以冒号（:）开头
> >
> > :hover :link  :active :focus
> >
> > **伪元素选择器**用于在元素的**特定部分添加样式或内容**，它们以双冒号（::）开头
> >
> > ::before  ::after
> >
> > css引入伪类和伪元素概念是**为了格式化文档树以外的信息**。 也就是说，伪类和伪元素是用来**修饰不在文档树中的部分**，比如，一句话中的第一个字母，或者是列表中的第一个元素。
> >
> > 伪类用于当已有的元素处于**某个状态时，为其添加对应的样式**，这个状态是**根据用户行为而动态变化的**。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。
> >
> > 伪元素用于**创建一些不在文档树中的元素，并为其添加样式**。**它们允许我们为元素的某些部分设置样式**。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。
> >
> > :before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after。
>
> **关于伪类 LVHA 的解释**
>
> > 就是因为**层叠性**，**选择器优先级都一样**，最终就是按照**书写位置决定样**式，后书写的会覆盖前书写的
> >
> > a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类 **:link、:visited、:hover、:active；**
> >
> > 当链接未访问过时： （1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明； （2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。 因此得出**LVHA**这个顺序。
> >
> > 当链接访问过时，情况基本同上，只不过需要将:link换成:visited。
> >
> > 
>
>  **LVHA这个顺序能不能变？**
>
> > 可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。

### 3.对 line-height 是如何理解的？

> ![](E:\Front\八股文\My八股文\八股图\line-height.webp)
>
> `line-height`指的是一行字的高度，包含了字间距，实际上是**下一行基线到上一行基线的距离**。
>
>  如果一个标签没有定义`height`属性，那么其最终表现的高度是由`line-height`决定的。
>
>  一个容器没有设置高度，那么撑开容器的高度的是`line-height`,而不是容器内部的文字内容。 把`line-height`值设置为`height`一样大小的值可以实现单行文字的垂直居中。 `line-height`和`height`都能撑开一个高度，`height`会触发`haslayout`，而`line-height`不会。

### 4.为什么img是inline还可以设置宽高

> img属于替换元素，替换元素一般有内在尺寸和宽高比，所以具有width和height，可设定
>
> HTML中的替换元素：img、input、textarea、select  video audio  iframe
>
>
> 在HTML中，**替换元素**（replaced element）是指那些在渲染过程中由浏览器根据元素的标签和属性内容来生成实际显示的元素。`<img>` 元素是其中一个常见的替换元素。
>
> 替换元素与非替换元素（non-replaced element）相对。非替换元素的内容**由其包含的文本或子元素决定**，而替换元素的内容则**由其本身的特性和外部资源决定**。替换元素通常是无法通过CSS来控制其内容的外观和渲染。

### 5.什么是浮动？用处 清除浮动

> [YK菌](https://blog.csdn.net/weixin_44972008/article/details/110734655)
>
> 给父级元素添加 `overflow` 属性并设置为非默认值，可以触发 `BFC`，创建一个独立的渲染环境，从而清除浮动并正确计算父级元素的高度。这是一种常用的清除浮动的方法之一，但在实际使用中需要注意兼容性和特定场景的考虑。

### 6.什么是定位？用处

> [YK菌](https://blog.csdn.net/weixin_44972008/article/details/110734680)

### 7.display 有哪些值？说明他们的作用。

> `block`    **块**级元素。默认宽度为**父元素宽度**，可设置**宽高**，换行**显示**。
>
>  `none`    元素**不显示**，并从**文档流中移除**。 
>
> `inline`    行内元素类型,**内联元素**。**默认宽度为内容宽度，不可设置宽高，同行显示。**
>
>  `inline-block`**默认宽度为内容宽度，可以设置宽高，同行显示。**
>
>  `list-item`    像块类型元素一样显示，并添加样式列表标记。
>
>  `table`    此元素会作为块级表格来显示。
>
>  `inherit`    规定应该从父元素继承display属性的值。
>
>  `grid` 定义一个容器属性为网格布局 它的子元素会按照网格布局进行排列。网格布局（Grid）是另一种强大的布局模型，可用于创建复杂的网格结构，实现灵活的网格布局。
>
> `flex`	定义一个弹性布局 元素被显示为弹性盒子容器，它的子元素会按照一定的规则进行布局。弹性盒子布局（Flexbox）是一种强大的布局模型，可用于实现灵活的盒子布局，使元素在水平和垂直方向上具有灵活的伸缩性。

### 8.负外边距

> [YK](https://juejin.cn/post/6984782638502543396#heading-7)

### 9.谈谈你对BFC的理解？

> ### 定义
>
> 块级格式化上下文（block formatting context,BFC)
>
> 具有 BFC 特性的元素可以看作是**隔离了的独立容器**，容器里面的元素**不会在布局上影响到外面的元素**，并且 BFC 具有普通容器所没有的一些特性。
>
> ### 触发方式/哪些元素会生成BFC
>
> 1. 根元素，即HTML标签
> 2. 浮动元素：float值为left或right
> 3. 定位元素：position为fixed或absolute的元素
> 4. overflow值不为visible，为auto、scroll、hidden的元素
> 5. display值为inline-block、table-cell、table-caption、flex、inline-flex的元素
>
> ### 约束规则
>
> 1. 内部的Box会在**垂直方向上一个接一个的放置**
> 2. 垂直方向上的距离由margin决定。（完整的说法是：**属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷**），与方向无关。）
> 3. **每个元素的左外边距与包含块的左边界相接触（从左向右）**，即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）
> 4. BFC的区域不会**与float的元素区域重叠**
> 5. 计算BFC的高度时，**浮动子元素也参与计算**
> 6. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然
>
> ### 作用
>
> 1. 阻止相邻元素**margin**合并（**防止margin重叠（塌陷）**）
>
>    两个相邻Box垂直方向margin重叠(Box垂直方向的距离由margin决定。属于同一个BFC(上例中是body根元素的BFC)的两个相邻Box的margin会发生重叠)
>
>    相邻Box水平方向margin重叠
>
>    嵌套元素的margin重叠
>
> 2. 清除内部的浮动(计算BFC的高度时，浮动元素也参与计算)
>
> 3. 可以用来自**适应两栏布局**(每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。   BFC的区域不会与float box重叠。)
>
> 4. 阻止元素被浮动元素覆盖
>
> 5. 可用来清除浮动带来的**外边距塌陷**问题
>
> 6. 阻止因浏览器四舍五入造成**的多列布局换行**的情况

### 10. css中，有哪些方式可以隐藏页面元素？区别?

> 关于`display: none`、`visibility: hidden`、`opacity: 0`的区别，如下表所示：
>
> |                        | display: none | visibility: hidden | opacity: 0 |
> | :--------------------- | :------------ | :----------------- | ---------- |
> | 页面中                 | 不存在        | 存在               | 存在       |
> | 重排                   | 会            | 不会               | 不会       |
> | 重绘                   | 会            | 会                 | 不一定     |
> | 自身绑定事件           | 不触发        | 不触发             | 可触发     |
> | transition             | 不支持        | 支持               | 支持       |
> | 子元素可复原           | 不能          | 能                 | 不能       |
> | 被遮挡的元素可触发事件 | 能            | 能                 | 不能       |
>
> - display:none
> - visibility:hidden
> - opacity:0
> - 设置height、width模型属性为0
> - position:absolute
> - clip-path
>
> > - `opacity=0;` 元素透明度为0，该元素被隐藏起来，但不会改变页面布局，如果该元素已经绑定一些事件，仍能触发
> > - `visibility=hidden;`元素不可见但仍然存在，不会改变页面布局，但不会触发该元素已经绑定的事件
> > - `display:none;`元素不显示并且会改变页面布局，可理解为该元素从页面中被删除
> >
> > 从占据空间角度看： `display: none;`会让元素完全从渲染树中消失，渲染的时候不占据任何空间； `visibility:  hidden;`不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见；
> >
> > 从继承方面角度看： `display: none;`是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示； `visibility:hidden;`是继承属性，子孙节点消失由于继承了hidden，通过设置`visibility: visible;`可以让子孙节点显式；
> >
> > 从重绘和重排角度看： 修改常规流中元素的`display`通常会造成文档重排。 修改`visibility`属性只会造成本元素的重绘
> >
> > 读屏器不会读取`display: none;`元素内容；会读取`visibility: hidden`元素内容

### 11.什么是外边距重叠？ 重叠的结果是什么？

> >  **是什么**
> >
> > 在CSS中，**两个或多个毗邻的普通流中的盒子**（可能是父子元素，也可能是兄弟元素）**在垂直方向上的外边距会发生叠加**，这种形成的外边距称之为外边距叠加。
>
> > **什么时候会发生外边距折叠？**
> >
> > 1. 相邻同级元素
> >
> > 当我们使用 **margin** 属性定义盒子元素的垂直外边距时，可能会出现外边距的合并。
> >
> > 也就是当上下两个块级兄弟元素相邻时，如果上边元素设置了下外边距 **margin-bottom**，并且下元素也设置了上外边距 **margin-top**，此时它们之间的垂直距离并不是 **margin-bottom** 与 **margin-top** 之和，而是取这两个属性值的最大者。这种现象就是**相邻块元素垂直外边距的重叠（合并）**。
> >
> > 2. 嵌套父级元素
> >
> > 当父元素与后代元素之间没有内容时，父级元素和子元素的外边距会发生重叠（塌陷）。
> >
> > 3. 空的块级元素
> >
> > 当一个块级元素的上外边距 **margin-top** 贴到另一个元素的下外边距 **margin-bottom**，并且该块级元素是空的，也就是没有设置边框 **border**、没有内边距 **padding**、没有高度 **height**、没有最大高度或最小高度、内容设定为 **inline** 或者清除浮动 **clear-fix**，那么此时也会发生外边距重叠情况。
>
> > **外边距折叠后的大小**　
> >
> > 两个相邻的外面边距是正数时，折叠结果就是他们之中的较大值； 
> >
> > 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值； 
> >
> > 两个外边距一正一负时，折叠结果是两者的相加的和；
>
> > **如何避免外边距折叠**
> >
> > - **浮动元**素不会与任何元素发生叠加，也包括它的子元素
> > - **创建了BFC的元素**不会和它的子元素发生外边距叠加
> > - **绝对定位元素**和其他任何元素之间不发生外边距叠加，也包括它的子元素
> > - **inline-block**元素和其他任何元素之间不发生外边距叠加，也包括它的子元素

### 12.CSS3新增了哪些新特性？

> **新增了一些选择器**
>
> 1. 属性选择器
> 2. 结构伪类选择器
> 3. 伪类选择器 
>
> **新样式**
>
> 1. 边框
> 2. 背景
> 3. 文字
> 4. 颜色
>
> **过渡**
>
> **转换**
>
> **动画**
>
> **渐变**

### 13.css3动画有哪些？

> transition
>
> transform
>
> animation
>
> [详解](https://segmentfault.com/a/1190000022540857)

### 14.transition有哪些属性？

> - transition-property 规定设置过渡效果的css属性名称，常用值 “all”全部css属性进行动画效果添加
> - transition-duration 规定完成过渡效果需要多少秒或毫秒
> - transition-timing-function 指定过渡函数，规定速度效果的速度曲线 常用值：关键字描述：linear ease ease-in ease-out ease-in-out
> - transition-delay 指定开始出现的延迟时间

### 15.新增伪类

> 1. **E: only-child**----------如果E是父元素下唯一的子元素，则选中之。
> 2. **E: first-child**---------匹配父元素的第一个子元素E
> 3. **E: last-child**---------匹配父元素的最后一个子元素E
> 4. **E: nth-child(n)**------------匹配父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数 值，也可以接受函数。
> 5. **E: nth-last-child(n)**----------作用同上，不过是从后开始查找。
>
> 
>
> 1. **E: only-of-type**  ---------如果父元素下的子元素只有一个elem类型元素，则选中该元素。
> 2. **E: first-of-type** --------- 选中父元素下第一个elem类型元素。
> 3. **E: last-of-type**  ---------选中父元素下最后一个elem类型元素。
> 4. **E: nth-of-type(n)** ---------匹配父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。
>
> 
>
> 1. **E:empty**  ---------选中不包含子元素和内容的elem类型元素。
> 2. **E:target** --------- 选择当前活动的elem元素。
> 3. **:not(elem)**  ---------选择非elem元素的每个元素。
>
> 
>
> 1. **:enabled**  ---------控制表单控件的禁用状态。
> 2. **:disabled**  --------- 控制表单控件的禁用状态。
> 3. **:checked** ---------单选框或复选框被选中。

### 16.说说flexbox（弹性盒布局模型）,以及适用场景？

> 

### 17.介绍一下grid网格布局

> 

###  18.grid布局和flex布局的区别

> 

### 19.box-sizing 常用的属性有哪些？分别有什么作用？

> ```CSS
> box-sizing: content-box; // 默认的标准(W3C)盒模型元素效果；
> box-sizing: border-box; // 触发怪异(IE)盒模型元素的效果；
> box-sizing: inherit; // 继承父元素 box-sizing 属性的值；
> ```

### 20 rgba() 和 opacity 的透明效果有什么不同？

> `opacity` 作用于元素以及元素内的所有内容（包括文字）的透明度；
>
> `rgba()` 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果；

### 21 说说em/px/rem/vh/vw区别?

> 1. **px:****`px`为绝对单位，在于`px`的大小和元素的其他属性无关**
>
> 2. **em:** **是相对长度单位, 相对于【父元素】，不常用**   基准点为父节点字体的大小，如果自身定义了`font-size`按自身来计算，整个页面内`1em`不是一个固定的值
>
> 3. **rem: 相对长度单位，相对于【html根元素】**，常用于响应式布局 在html设置font-size，其他元素可以继承，使用rem单位
>
> 4. **vh、vw**:  主要用于页面视口大小布局，在页面布局上更加方便简单
>
> > 就是**根据窗口的宽度**，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，`vh`则为窗口的高度
> >
> > 这里的窗口分成几种情况：
> >
> > - 在桌面端，指的是**浏览器的可视区域**
> > - 移动端指的就是**布局视口**
> >
> > 像`vw`、`vh`，比较容易混淆的一个单位是`%`，不过百分比宽泛的**讲是相对于父元素：**
> >
> > - 对于普通定位元素就是**我们理解的父元素**
> > - 对于position: absolute;的元素是相对于已定位的父元素
> > - 对于position: fixed;的元素是**相对于 ViewPort（可视窗口）**

### 22响应式 media query 媒体查询

> 

### 23 如何让盒子垂直居中   元素水平垂直居中的方法有哪些？如果元素不定宽高呢？

> > - **利用定位+margin:auto**
> >
> > 设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水 平和垂直方向上的居中
> >
> > - **利用定位+margin:负值**
> >
> > 先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素 的中心点到页面的中心
> >
> > - **利用定位+transform**
> >
> > 先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素 的中心点到页面的中心
> >
> > - table布局
> > - **flex布局**
> >
> > 通过`align-items:center`和`justify-content:center`设置容器的垂直和水平方向上为居中对 齐，然后它的子元素也可以实现垂直和水平的居中。
> >
> > - grid布局
>
> > 上述方法中，不知道元素宽高大小仍能实现水平垂直居中的方法有：
> >
> > - 利用定位+margin:auto
> > - 利用定位+transform
> > - flex布局
> > - grid布局
>
> > 根据元素标签的性质，可以分为：
> >
> > - 内联元素居中布局
> > - 块级元素居中布局
> >
> > **内联元素居中布局内联元素居中布局**
> >
> > 水平居中
> >
> > - 行内元素可设置：text-align: center
> > - flex布局设置父元素：display: flex; justify-content: center
> >
> > 垂直居中
> >
> > - 单行文本父元素确认高度：height === line-height
> > - 多行文本父元素确认高度：display: table-cell; vertical-align: middle
> >
> > **块级元素居中布局**
> >
> > 水平居中
> >
> > - 定宽: margin: 0 auto
> > - 绝对定位+left:50%+margin:负自身一半
> >
> > 垂直居中
> >
> > - position: absolute设置left、top、margin-left、margin-top(定高)
> > - display: table-cell
> > - transform: translate(x, y)
> > - flex(不定高，不定宽)
> > - grid(不定高，不定宽)，兼容性相对比较差

### 24 用纯 CSS 创建一个三角形的原理是什么？

> 采用的是相邻边框连接处的均分原理。
>  将元素的宽高设为0，只设置  border  ，把任意三条边隐藏掉（颜色设为  transparent），剩下的就是一个三角形。
>
> ```css
> #demo {
>   width: 0;
>   height: 0;
>   border-width: 20px;
>   border-style: solid;
>   border-color: transparent transparent red transparent;
> }
> ```

### 25一个满屏品字布局如何设计?

> 三个div原本是垂直安放的
>
> 将上面的盒子    margin-bottom: 50px;    margin-left: 30%;
>
> 下面的盒子  float: left;      float: right;
>
> ```css
> .content {
>     width: 50%;
>     height: 150px;
>     margin: 0 auto;
> }
> .top {
>     width: 40%;
>     height: 50px;
>     background-color: pink;
>     margin-bottom: 50px;
>     margin-left: 30%;
> }
> .left {
>     width: 45%;
>     height: 50px;
>     background-color: pink;
>     float: left;
> }
> .right {
>     width: 45%;
>     height: 50px;
>     background-color: pink;
>     float: right;
> }
> -------------
> <div class="content">
>     <div class="top"></div>
>     <div class="left"></div>
>     <div class="right"></div>
> </div>>
> ```

### 26 CSS 多列等高如何实现？

> 

### 27 三种文档流

> 

### 28 页面布局方式

> 

### 29 CSS预处理器/后处理器是什么？为什么要使用它们？

> 预处理器，如：**less，sass，stylus,** 用来预编译sass或者less，增加了css代码的复用性，还有层级，mixin， 变量，循环， 函数等，对编写以及开发UI组件都极为方便。
>
> 后处理器， 如： postCss,  通常被视为在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器**私有前缀，实现跨浏览器兼容性的问题**。
>
> **结构清晰， 便于扩展** 可以很方便的**屏蔽浏览器私有语法的差异** 可以轻松实现**多重继承** 完美的**兼容**了CSS代码，可以应用到老项目中

### 30 link 与 @import 的区别？

> 1. `link`是一个HTML标签，用于在HTML文档中引入外部样式表。它使用以下语法：
>
> ```css
> <link rel="stylesheet" type="text/css" href="style.css">
> ```
>
> `@import`是CSS规则，用于在CSS文件中引入外部样式表。
>
> ```css
> @import url("style.css");
> ```
>
> 2. 加载顺序 
>
>    `link`**最大限度支持并行下载**，使用`link`标签可以在HTML文档加载过程中同时加载外部样式表，这意味着样式表与页面内容的加载是并行进行的，可以更快地渲染页面
>
>    `@import`**过多嵌套导致串行下载，出现FOUC**  其是在CSS文件加载过程中才会下载和加载外部样式表，这会导致页面的加载速度稍慢。
>
>    > FOUC（Flash of Unstyled Content）。
>    >
>    > **FOUC是指在网页加载过程中，由于样式表的延迟加载或下载的顺序问题，导致页面在样式表加载完成之前呈现无样式的内容，然后突然应用样式，给用户带来不良的视觉体验**。
>
> 3. 兼容性  `link`标签的兼容性更好，几乎适用于所有的浏览器。而`@import`在较旧的浏览器版本中可能不被支持
> 4. 优先级 使用`link`标签引入的样式表具有更高的优先级，可以覆盖`@import`引入的样式。这是因为`@import`引入的样式表会在其他样式加载完成后才会被解析。
>

> - `rel`（Relationship）：指定**当前文档与被链接文档之间的关系**。在引入样式表时，使用`rel`属性的值为`stylesheet`，表示被链接的文档是一个**样式表**。
> - `type`：指定**被链接文档的MIME类型**（Multipurpose Internet Mail Extensions）。在引入CSS样式表时，使用`type`属性的值为`text/css`，表示被链接的文档是CSS文件。
> - `href`（Hypertext Reference）：指定**被链接文档的URL**（Uniform Resource Locator），即外部样式表的文件路径。在这里，`href`属性的值是`style.css`，表示要引入的样式表文件名为`style.css`。

### 31 css sprites是什么？如何使用？

> **作用:**有效地减少服务器接受和发送请求的次数,提高页面的加载速度
>
> **核心的原理是:** 将一堆小背景图像整合到一张大图中,这样服务器只请求一次就可以了
>
> 利用`CSS`的`“background-image”，“background- repeat”``，“background-position”`的组合进行背景定位background-position可以用数字能精确的定位出背景图片的位置，减轻服务器对图片的请求数量。

### 32 style标签写在body后与body前有什么区别？

> 一般情况下，页面加载时自上而下的。
>
> 将style标签至于body之前，为的是先加载样式。 
>
> 若是写在body标签之后，由于浏览器以逐行方式对html文档进行解析，当解析到写在写在文档尾部的样式表时，会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后会重新渲染，在windows的IE下可能会出现FOUC现象（页面闪烁）。

### 33 圣杯布局和双飞翼布局

> ![](E:\Front\八股文\My八股文\八股图\圣杯布局和双飞翼布局.png)
>
> 1. **作用**
>
> 圣杯布局和双飞翼布局解决的问题是相同的，就是
>
> 1. **两边宽度固定，中间宽度自适应的**
>
> 2. **三栏布局**，**中间栏要在放在文档流前面以优先渲染。**
>
> 2. **区别**
>
> **圣杯布局：**为了让中间div内容不被遮挡，**将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性**，以便左右两栏div移动后不遮挡中间div。
>
> **双飞翼布局：**为了让中间div内容不被遮挡，**直接在中间div内部创建子div用于放置内容**，在该div里用margin-left和margin-right为左右两栏div留出位置
>
> ??????????

### 34 png、jpg、 jpeg、 bmp、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？

> **png**:无损压缩的位图图像格式  需要保留高质量细节和透明度的情况下使用 文件较大
>
> **jpf:**有损压缩的图像格式  主要用于存储照片和真实场景图像。JPEG格式适用于颜色丰富、细节丰富的图像，可以在较小的文件大小下提供高质量的图像显示。然而，JPEG不支持透明度，适用于静态图像
>
> **GIF:**无损压缩的图像格式 支持动画和透明背景。GIF格式适用于简单的图标、动画、简单的图形等场景。然而，GIF的颜色表限制和较低的色彩深度使其不适合显示颜色丰富的照片等复杂图像。
>
> **BMP**:BMP 是一种无损的位图图像格式 高质量图片 缺点： 体积太大； 适用场景： windows桌面壁纸；
>
> **WebP**，它是一种由Google开发的图像格式，旨在**提供更高的压缩率和更好的图像质量**。WebP支持有损和无损压缩，以及透明度和动画。WebP格式在保持图像质量的同时，可以显著减小图像文件大小，从而加快页面加载速度。WebP格式适用于现代Web应用程序，并在支持该格式的浏览器中获得更好的性能。然而，由于WebP是相对较新的图像格式，某些旧版本的浏览器可能不支持它。兼容性不好
>
> 总结来说，根据不同的需求和场景，选择合适的图片格式可以在保持图像质量的同时，有效控制文件大小和加载速度。PNG适用于透明度和图像细节要求高的图像，JPEG适用于照片和真实场景图像

### 35 简单介绍使用图片 base64 编码的优点和缺点。

> 一种图片处理格式 使用图片的Base64编码是将**图片数据**转换为**一串Base64编码的字符串**，可以直接在CSS或HTML中使用，而无需额外的图片文件
>
> **优点：**
>
> 1. **减少HTTP请求：**使用Base64编码可以将图片直接嵌入到HTML或CSS文件中，避免了额外的图片文件请求，从而减少了HTTP请求的数量。这对于小的图标或较小的图片可以提高页面加载性能。
> 2. **快速渲染：**由于无需等待图片的下载和解析，使用Base64编码的图片可以更快地进行渲染，减少了页面加载的延迟。
> 3. **方便部署和传输：**使用Base64编码的图片可以直接嵌入到代码中，减少了部署和传输图片文件的麻烦。这对于小规模项目或需要便捷交付的场景非常有用。
>
> **缺点：**
>
> 1. **文件大小增加**：根据base64的编码原理，编码后的大小会比原文件大小**大1/3**，如果把大图片编码到html/css中，不仅会造成**文件体积的增加**，**影响文件的加载速度**，还会增加浏览器对html或css文件解析**渲染的时间**。
> 2. **缓存问题：**由于Base64编码的图片嵌入在HTML或CSS中，每次更改图片内容或样式时，都需要重新编码和更新代码。这导致无法从浏览器缓存中获得图片的好处，而且可能会增加HTML或CSS文件的大小。
> 3. **可维护性差：**使用Base64编码的图片使得代码变得冗长，**可读性较差，不便于维护和修改**。对于大型项目或需要频繁更改的情况，使用独立的图片文件更具可维护性。
> 4. **兼容性问题:** ie8以前的浏览器不支持。
>
> 一般一些网站的小图标可以使用base64图片来引入。·

-----

> 以下是三种实现两栏布局的方法：
>
> **1. 使用浮动（Float）：** HTML结构：
>
> ```
> htmlCopy code<div class="container">
>   <div class="left-column">Left Column</div>
>   <div class="right-column">Right Column</div>
> </div>
> ```
>
> CSS样式：
>
> ```
> cssCopy code.container {
>   overflow: hidden; /* 清除浮动 */
> }
> 
> .left-column {
>   float: left;
>   width: 30%;
> }
> 
> .right-column {
>   margin-left: 30%;
> }
> ```
>
> **2. 使用Flexbox布局：** HTML结构：
>
> ```
> htmlCopy code<div class="container">
>   <div class="left-column">Left Column</div>
>   <div class="right-column">Right Column</div>
> </div>
> ```
>
> CSS样式：
>
> ```
> cssCopy code.container {
>   display: flex;
> }
> 
> .left-column {
>   flex: 0 0 30%;
> }
> 
> .right-column {
>   flex: 1;
> }
> ```
>
> **3. 使用Grid布局：** HTML结构：
>
> ```
> htmlCopy code<div class="container">
>   <div class="left-column">Left Column</div>
>   <div class="right-column">Right Column</div>
> </div>
> ```
>
> CSS样式：
>
> ```
> cssCopy code.container {
>   display: grid;
>   grid-template-columns: 30% 1fr;
> }
> 
> .left-column {
>   grid-column: 1;
> }
> 
> .right-column {
>   grid-column: 2;
> }
> ```
>
> 这些是三种常见的实现两栏布局的方法。每种方法都有其适用的场景和特点，请根据具体需求选择合适的方法。