### 1. 数组

#### 1.1 数组理论基础

-----

#### 1.2 二分查找

> ##### 704.二分查找
>
> ```js
> //左闭右闭区间 [left, right]
> let mid, left = 0, right = nums.length-1;
> while (left <= right)
> right = mid - 1;  // 去左面闭区间寻找
> left = mid + 1;   // 去右面闭区间寻找
> ```
>
> ```js
> //左闭右开区间 [left, right)
> let mid, left = 0, right = nums.length;
> while (left < right)
> right = mid;  // 去左区间寻找
> left = mid + 1;   // 去右区间寻找
> ```
>
> ```js
> //mid 取数的方式
> mid = left + ((right - left) >> 1);
> mid = Math.floor((left + right) / 2);
> ```

> **35.搜索插入位置**
>
> `O(log n)`一般是**二分法**
>
> `nums` 为 **无重复元素** 的 **升序** 排列数组 **二分法**
>
> **中心的思想**：是找到第一个大于等于target的元素
>
> **分情况：**
>
> - 目标值在数组所有元素之前
> - 目标值等于数组中某一个元素
> - 目标值插入数组中的位置
> - 目标值在数组所有元素之后
>
> 用ans记录比目标值大的元素，最后一个就是其插入的位置，ans的初始值为数组的长度

> **34. 在排序数组中查找元素的第一个和最后一个位置**
>
> **二分查找**，找左右边界
>
> **左边界：**记录最后一个大于目标值的数
>
> **右边界：**记录最后一个小于目标值的数
>
> **分情况判断：**
>
> - 情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}
> - 情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}
> - 情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1} 

> **69.x的平方根**
>
> 采用二分查找查找
>
> `left=0`
>
> `right=Math.ceil(x / 2) + 1`
>
> 找最后一个`mid * mid <= x`
>
> 找最后一个`mid * mid > x`

> **367.有效的完全平方数**
>
> 同上

-----

#### 1.3 移除元素

##### 27.移除元素

> 双指针法

##### 26.删除排序数组中的重复项

> 双指针法

##### 283.移动零

> 双指针

##### 844.比较含退格的字符串

> **Way1**：用stack
>
> **Way2：**定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。

##### 977.有序数组的平方

> 双指针

-----

#### 1.4 有序数组的平方

##### 977.有序数组的平方

> 

-----

#### 1.5 长度最小的子数组

##### 209.长度最小的子数组

> 运用滑动窗口
>
> 当满足条件之后开始缩小
>
> 注意初始值，若是没有则返回**0**

-----

##### 904.水果成篮

>  **cns.delete(fruits[left])**  删除map里面的元素

##### 706.最小覆盖子串

> ASCII表：
>
> 0-9—48-57 
>
> A-Z—65-90
>
> a-z—97-122
>
> **str.charCodeAt(i):**charCodeAt() 方法可返回指定位置的字符的 Unicode 编码
>
> s[left].toLowerCase() //转小写的
>
> s[left].toUpperCase() //转大写的
>

---

#### 1.6 长度最小的子数组

##### 59.螺旋矩阵

> 

#### 1.7总结

> 

-----

### 2. 链表

#### 2.1 链表的理论基础

-----

#### 2.2 移除链表元素

> **let dump = new ListNode(0, head)**

---

#### 2.3 设计链表

---

#### 2.4 翻转链表

> 1. 注意翻转后的链表的尾指针要指**null**
> 2. 可以用**栈**进行存储 再依次的取出来

---

#### 2.5 两两交换链表中的节点

---

#### 2.6 删除链表的倒数第N个节点

---

#### 2.7 链表相交

>   if (lenA < lenB) {    *// 让curA为最长链表的头，lenA为其长度*
>
> 
>
> ​    *// 交换变量注意加 “分号” ，两个数组交换变量在同一个作用域下时*
>
> ​    *// 如果不加**分号**，下面两条代码等同于一条代码: [curA, curB] = [lenB, lenA]*
>
> ​		//！！！！！！注意加分号
>
> ​    [curA, curB] = [curB, curA];
>
> ​    [lenA, lenB] = [lenB, lenA];
>
>   }

-----

#### 2.8环形链表Ⅱ

> 

-----

#### 2.9 总结篇

> const endOfFirstHalf = (head) => {
>     let fast = head;
>     let slow = head;
>     while (fast.next !== null && fast.next.next !== null) {
>         fast = fast.next.next;
>         slow = slow.next;
>     }
>     return slow;
> }
>
> 找到后半部分的链表 一定要先next 在next.next!=null 在进行判断

-----

### 3. 哈希表

#### 3.1 哈希表理论基础

-----

#### 3.2 有效的字母异位词

> **242.有效的字母异位词**
>
> ```js
>     for (let i = 0; i < lenS; i++) {
>         ++arrS[s.charCodeAt(i) - 'a'.charCodeAt()]
>         ++arrT[t.charCodeAt(i) - 'a'.charCodeAt()]
>     }
>     if (arrS.toString() === arrT.toString()) {
>         return true
>     } else {
>         return false
>     }
> ```
>
> ```js
> //将字符串转换为数组
> let array = Array.from(s)
> //排序
> array.sort()
> //在转换为字符串
> let str = array.toString()
> ```

> **383. 赎金信**

> **49.字母异位词分组**
>
> ```js
> return Array.from(map.values())
> [...map.keys()] 一样的
> //[Map Iterator] { [ 'eat', 'tea', 'ate' ], [ 'tan', 'nat' ], [ 'bat' ] }
> //[ [ 'eat', 'tea', 'ate' ], [ 'tan', 'nat' ], [ 'bat' ] ]
> ```
>
> ```js
> //想要在map的值中追加东西
> let list = map.get(key) ? map.get(key) : new Array()
> list.push(str)
> map.set(key, list)
> ```

> **438.找到字符串中所有字母异位词**

-----

#### 3.3 两个数组的交集

> **349. 两个数组的交集**
>
> ```js
> //去重
> const set1 = new Set(nums1)
> const set2 = new Set(nums2)
> ```

> **350. 两个数组的交集Ⅱ**
>
> ```js
> //一种迭代的方式来是的set2总是最长的那个
> var intersect = function (nums1, nums2) {
>     if (nums1.length > nums2.length) {
>         return intersect(nums2, nums1)
>     }
> //先排序，在逐一进行比较
> ```

-----

#### 3.4 快乐数

> **202.快乐数**
>
> 快乐数，如果出现了循环，则说明不是快乐数 也就是重复
>
> 判断重复 两种方法 **快慢指针 set**
>
> 再看一下 具体的实现

#### 3.5 两数之和

> **1.两数之和**
>
> 查找一个元素是否在另一个元素中出现过 用哈希表
>
> 比较巧妙的方法是遍历一遍 边收集 边判断

#### 3.6 四数相加Ⅱ

> **454.四数相加Ⅱ**
>
> 两个数为一组 用hash记录**两数之和** 和**对应出现的次数**

#### 3.7 赎金信

> **383.赎金信**

#### 3.8 三数之和

> **15.三数之和**
>
> **注意一下排序的问题**
>
> nums.sort((a, b) => a - b)   [-3,-1,1,2]
>
> nums.sort() [-1,-3,1,2]
>
> 去重 对i去重 当找到目标的数的时候 才对left和right去重

#### 3.9 四数之和

> **18.四数之和**

### 4. 字符串

#### 4.1 翻转字符串

#### 4.2翻转字符串Ⅱ

>  [arr[left], arr[right]] = [arr[right], arr[left]]
>
>  对于数组 可以直接互换 对于字符串要小心 进行解构赋值 成数组在进行转化 最后在拼接成字符串
>
>   i += (2 \* k)，i 每次移动 2 \* k 就可以了，然后判断是否需要有反转的区间

#### 4.3替换字符串

> **其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

#### 4.4翻转字符串中的单词

> 先去掉空的多余的空格
>
> 若干是空格 并且 前面的那个字符也是空格 或者 是第一个字符 那么就跳过 最后 截取字符串的时候也要判断一个最后一个字符是不是空格 
>
> 再整体的翻转
>
> 再局部的翻转

#### 4.5 左旋转字符串

> 

#### 4.6 实现strStr()

> KMP

#### 4.7 重复字符串

> KMP

**150.逆波兰表达式求值.**

> 注意/号的运算
>
>   stack.push(op2 / op1 > 0 ? Math.floor(op2 / op1) : Math.ceil(op2 / op1));

